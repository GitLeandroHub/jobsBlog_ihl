{"componentChunkName":"component---src-components-templates-blog-template-tsx","path":"/blog/restoring-blank-seed-phrase","result":{"data":{"mdx":{"frontmatter":{"author":"Afri Schoedon","date_published":"May 17, 2017","image":"","slug":"blog/restoring-blank-seed-phrase","tags":["Parity Ethereum"],"blogTitle":"Restoring & blank seed phrase"},"body":"var _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar _frontmatter = {\n  \"title\": \"index\",\n  \"tags\": [\"Parity Ethereum\"],\n  \"author\": \"Afri Schoedon\",\n  \"blogTitle\": \"Restoring & blank seed phrase\",\n  \"slug\": \"blog/restoring-blank-seed-phrase\",\n  \"date_published\": \"2017-05-17T04:00:00.000Z\",\n  \"image\": \"\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"It has come to our attention that a small minority of users have misunderstood a function within Parity Wallet, and in doing so have created insecure accounts. TL;DR: \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Don't use the \\\"RECOVERY PHRASE\\\"/\\\"IMPORT WALLET\\\" function to generate a fresh account. That's not what it's for. If you see the word \\\"import\\\" or \\\"recover\\\" anywhere, then you're not generating anything fresh, you importing something that (is meant to) already exist.\")), mdx(\"p\", null, \"When adding an account, Parity Wallet provides you with a number of different functions, depending on whether you want to restore a previous account, generate a new account or link an existing account managed by an external device.\"), mdx(\"p\", null, \"If you simply wish to generate a fresh, secure account, then the default option \\\"NEW ACCOUNT\\\" is for you. You can click through with the \\\"NEXT\\\" button and it'll take you through the remaining steps.\"), mdx(\"p\", null, \"The other (non-default) options allow you to add previously generated accounts, either importing from key files (\\\"GETH KEYSTORE\\\", \\\"JSON FILE\\\", \\\"PRESALE WALLET\\\") or importing from the private key directly (\\\"RECOVERY PHRASE\\\", \\\"PRIVATE KEY\\\").\"), mdx(\"p\", null, \"The \\\"RECOVERY PHRASE\\\" function is described on the page as:\"), mdx(\"h4\", null, \"Recover using a previously stored recovery phrase and new password\"), mdx(\"p\", null, \"This means that you can import an previously generated account using its recovery phrase. A recovery phrase is a phrase which can be used to generate a specific private key; it's a piece of information that fundamentally unlocks a particular account. It is generally unencrypted and is the last best chance of saving an old account if you forget everything else about it. It's the sort of thing you write on a piece of paper and leave locked in a safe.\"), mdx(\"p\", null, \"As such any account generated from a recovery phrase is only as secure as its recovery phrase. Additional passwords don't help since anyone can use this recovery phrase function to recover the underlying private key - the key that always unlocked the account - anyway. Try it! Generate a \\\"NEW ACCOUNT\\\", copy the recovery phrase, delete it and that restore it using the \\\"RECOVERY PHRASE\\\" option. It will be the very same account address.\"), mdx(\"p\", null, \"Parity doesn't let you use the \\\"NEW ACCOUNT\\\" feature to author your own security phrase: humans are not very good at coming up with secure phrases when they generate accounts. Instead it gives you one that is designed to be completely secure (it has the same amount of entropy as an Ethereum address) and has you write that down.\"), mdx(\"p\", null, \"However, Parity does allow you to \\\"IMPORT\\\" a pre-existing account using its recovery phrase.\"), mdx(\"p\", null, \"The resultant account, of course, is only as secure as its recovery phrase. If the account you imported was the result of a simple (low-entropy) recovery phrase, then it will be accordingly insecure.\"), mdx(\"p\", null, \"The most insecure recovery phrase is the empty one. It's so insecure that it's used to place all of the Ether on the local development chain so that everyone can get access to it. Parity doesn't yet check that you don't use such an insecure phrase to import an account on the main net (mainly because accounts were shared between main net and development chains until a couple of releases ago). It will do soon.\"), mdx(\"p\", null, \"In the mean time:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"DO NOT USE THE \\\"IMPORT WALLET\\\"/\\\"RECOVERY PHRASE\\\" OPTION WHEN YOU WANT TO GENERATE A FRESH ACCOUNT.\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Use the \\\"NEW ACCOUNT\\\" option to generate a fresh, new account.\")), mdx(\"p\", null, \"We will be pushing out a swift patch release, making it substantially less easy to accidentally import an account from an insecure recovery phrase with Parity Wallet. We will also be revamping the dialog workflows to ensure import functionality is separated from account-generation functionality.\"));\n}\n;\nMDXContent.isMDXComponent = true;","timeToRead":2,"excerpt":"It has come to our attention that a small minority of users have misunderstood a function within Parity Wallet, and in doing so have createdâ€¦"},"allMdx":{"edges":[{"node":{"frontmatter":{"blogTitle":"We just released ink! 4.0!","date_published":"February 08, 2023","image":"/images/qsdh5p9.jpeg","slug":"we-just-released-ink-4-0"}}},{"node":{"frontmatter":{"blogTitle":"Parity Leadership Update","date_published":"October 21, 2022","image":"/images/blog-post.png","slug":"blog/parity-leadership-update/"}}},{"node":{"frontmatter":{"blogTitle":"Transitioning Parity Ethereum to OpenEthereum DAO","date_published":"December 16, 2019","image":"/images/parity-ethereum-openethereum.jpeg","slug":"blog/parity-ethereum-openethereum-dao/"}}}]}},"pageContext":{"slug":"blog/restoring-blank-seed-phrase","locale":"en","hrefLang":"en-US","originalPath":"/blog/restoring-blank-seed-phrase","dateFormat":"MM/DD/YYYY"}},"staticQueryHashes":["1239077767","1247656359","3280999885","3280999885","4123762078","4185913137","607815487","607815487"]}