{"componentChunkName":"component---src-components-templates-blog-template-tsx","path":"/blog/light-js-how-to-build-your-dapp-on-a-light-client/","result":{"data":{"mdx":{"frontmatter":{"author":"Amaury Martiny","date_published":"November 18, 2018","image":"/images/light-js-web3-library.jpeg","slug":"blog/light-js-how-to-build-your-dapp-on-a-light-client/","tags":["Light.js","Parity Fether","Releases"],"blogTitle":"Light.js: How to Build Your Dapp on a Light Client"},"body":"var _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar _frontmatter = {\n  \"title\": \"index\",\n  \"tags\": [\"Light.js\", \"Parity Fether\", \"Releases\"],\n  \"author\": \"Amaury Martiny\",\n  \"blogTitle\": \"Light.js: How to Build Your Dapp on a Light Client\",\n  \"slug\": \"blog/light-js-how-to-build-your-dapp-on-a-light-client/\",\n  \"date_published\": \"2018-11-18T05:00:00.000Z\",\n  \"image\": \"/images/light-js-web3-library.jpeg\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"This article introduces a new JavaScript library, \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/paritytech/js-libs/tree/master/packages/light.js\"\n  }, \"light.js\"), \", which provides a set of high-level tools to build light-client-efficient Dapps. It is primarily aimed for Dapp developers looking for an alternative to web3.js.\"), mdx(\"h2\", null, mdx(\"strong\", {\n    parentName: \"h2\"\n  }, \"Why build on top of a light client?\")), mdx(\"p\", null, \"Running a full Ethereum node is laborious: it\\u2019s very challenging today to have end-users run full nodes on consumer laptops. As a result, Dapp developers rely on external services for their backend infrastructure. These services run at scale, but at the cost of centralizing node operators.\"), mdx(\"p\", null, \"Light clients solve this problem. A light client is a special kind of Ethereum node that is, as suggested by its name, light. Concretely, this means:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"low on resources usage: CPU, memory, storage, I/O operations\\u2026\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"embeddable: in a desktop application, on mobile, within a web app.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"but still remains trustless.\")), mdx(\"p\", null, \"If a Dapp is paired with its own light client to query state and make transactions, it does not need to rely on centralized infrastructures anymore. At InvisibleHandLab, we wish to embed light clients everywhere: in desktop and mobile apps, browser extensions, web apps\\u2026 We believe light clients will\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.parity.io/what-is-a-light-client\"\n  }, \" play a key role\"), \" in Ethereum mass adoption.\"), mdx(\"iframe\", {\n    className: \"w-full h-56 my-8 sm:h-80 md:h-96\",\n    src: \"https://www.youtube.com/embed/Hxzzj3lJKlw\",\n    allowFullScreen: true\n  }), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"Amaury Martiny presenting light.js at the Parity & Polkadot Devcon meetup\")), mdx(\"h2\", null, mdx(\"strong\", {\n    parentName: \"h2\"\n  }, \"Meet light.js\")), mdx(\"p\", null, \"We have built over fifteen Dapps for our now-defunct \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/parity-js/shell\"\n  }, \"Parity UI\"), \". When building these Dapps, we came across development patterns that were popping up again and again. For example, if we want to constantly show the latest balance of an ERC20 token for a particular address, we can do one of the following:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"poll the chain every 5 seconds\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"do some smart-polling, e.g. make a new call only once the previous call has finished\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"listen to incoming blocks via pub/sub, and only make a call on new block\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"listen to state changes via pub/sub (Parity only, see \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://wiki.parity.io/JSONRPC-parity_pubsub-module\"\n  }, \"the documentation\"), \")\")), mdx(\"p\", null, \"These patterns appear often in the Dapps ecosystem, if you are a Dapp developer, chances are you are using one of them.\"), mdx(\"p\", null, \"However, these are empirical patterns: they are well-known amongst Dapp developers, but are not always enforced.\"), mdx(\"p\", null, \"The goal of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"light.js\"), \" is simple:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"pick the best pattern that works with light clients: listen to headers via pub/sub and make API calls on new header, while making sure that the amount of network calls is not excessive.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"put it into a high-level library, so that Dapp developers use a simple API instead of following a supposedly well-known pattern.\")), mdx(\"p\", null, \"Concretely, it means:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"    // Before, with web3.js\\n    \\n    const contract = web3.eth.Contract(ABI, '0x00..ff');\\n    \\n    async function updateBalance() {  \\n        const balance = await contract.methods.balanceOf('0xabc').call(); \\n        console.log(balance);\\n    }\\n    \\n    // Dapp developer: \\\"This should be light-client-friendly...\\n    \\\"web3.eth.subscribe('newBlockHeaders').on('data', updateBalance);\\n    \\n    --- \\n    \\n    // Now, with light.js\\n    \\n    import { makeContract } from '@parity/light.js';\\n    // Dapp developer: \\\"I'm sure this is light-client-friendly!\\\"\\n    makeContract(ABI, '0x00..ff')\\n        .balanceOf$('0xabc')\\n        .subscribe(console.log); // Logs the result when balance changes\\n\")), mdx(\"h2\", null, mdx(\"strong\", {\n    parentName: \"h2\"\n  }, \"High-level reactive programming\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"light.js\"), \" is meant to be high-level: the Dapp developer calls a function and the library chooses the best pattern, handles caching, and does \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://parity-js.github.io/light.js/concepts/rpc-observables-properties.html\"\n  }, \"all the dirty work\"), \" behind the scenes.\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"light.js\"), \"; only exposes 10 high-level functions, amongst them:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"query the balance: \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"balanceOf$('0x123');\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"interact with contracts: \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"makeContract(abi, contractAddress);\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"post a transaction: \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"post$(myTx);\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"manage accounts: \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"account$();\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"etc. (you can find the full list in the \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://parity-js.github.io/light.js/api/modules/_rpc_eth_.html\"\n  }, \"documentation\"), \")\")), mdx(\"p\", null, \"We only expose ten functions, but they should cater to the needs of most Dapps today. For reference, we built a fully-featured Ethereum & ERC20 wallet on top of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"light.js\"), \", called \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/paritytech/fether\"\n  }, \"Parity Fether\"), \". Based on feedback, we might of course add new functions\\u2014feel free to \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/paritytech/js-libs/issues\"\n  }, \"create an issue\"), \" if you need one.\"), mdx(\"p\", null, \"You might have noticed the $ sign behind the names of the functions. This is a\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://stackoverflow.com/questions/43083577/what-does-sign-at-the-end-of-function-name-indicate\"\n  }, \" JavaScript convention\"), \" to represent Observables. Observables are a JavaScript structure that basically represents an ongoing asynchronous stream of data, ordered in time. Some examples that can be expressed in Observables:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"clicks on a button\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"tweets on your Twitter feed\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"new blocks on the Ethereum blockchain\")), mdx(\"p\", null, \"Data streams are an intuitive, high-level way to express changes happening on the Ethereum blockchain. The Observables in \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"light.js\"), \" fire when something changes, and the Dapp reacts to those changes. Moreover, Dapp developers can leverage the\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/ReactiveX/rxjs\"\n  }, \" huge ecosystem\"), \" around Observables to build complex Dapps with the basic ones provided by \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"light.js\"), \".\"), mdx(\"p\", null, \"To learn more about reactive programming, head towards\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://parity-js.github.io/light.js/concepts/reactive-programming.html\"\n  }, \" our documentation\"), \".\"), mdx(\"h2\", null, mdx(\"strong\", {\n    parentName: \"h2\"\n  }, \"Start hacking with light.js\")), mdx(\"p\", null, \"The best way to start hacking with \", \"`\", \"light.js \", \"`\", \"is to:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"download it from npm: \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"yarn install rxjs @parity/light.js\")), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"follow our 6-step tutorial: \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://parity-js.github.io/light.js/guides/tutorial1-set-up-a-light-client.html\",\n    \"title\": \"https://parity-js.github.io/light.js/guides/tutorial1-set-up-a-light-client.html\"\n  }, \"https://parity-js.github.io/light.js/guides/tutorial1-set-up-a-light-client.html\"))), mdx(\"p\", null, \"An important thing to note is that while \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"light.js\"), \" is optimized for light clients, it will of course work with full nodes, local or remote. In particular, it works out-of-the-box if you have MetaMask installed:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"import light, { balanceOf$ } from '@parity/light.js';\\n\\n// Wait for web3.currentProvider to be injected\\nwindow.addEventListener('load', () => {\\n  // Tell light.js to use MetaMask provider\\n  light.setProvider(window.web3.currentProvider);\\n\\n  balanceOf$('0x123').subscribe(console.log); // Logs the balance\\n});\\n\")), mdx(\"p\", null, \"Even if you can't embed a light-client in your app today for whatever reason, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"light.js\"), \" \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://parity-js.github.io/light.js/getting-started/does-it-work-with-a-full-node.html\"\n  }, \"works well with remote full nodes\"), \", so we do recommend \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"light.js\"), \" for any kind of Dapp. The day you decide to finally switch to a light client, you won\\u2019t have to change a single line of code.\"), mdx(\"p\", null, \"If you are writing your Dapp with React, we also provide light.js-react, a tiny library to integrate light.js easily with React apps:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-js\"\n  }, \"import * as React from 'react';\\nimport { balanceOf$ } from '@parity/light.js';\\nimport light from '@parity/light.js-react';\\n\\n@light({\\n  myBalance: () => balanceOf$('0x123')\\n})\\nclass MyComponent extends React.Component {\\n  render() {\\n    return (\\n      <div>\\n        The balance of \\\"0x123\\\" is {this.props.myBalance.toFormat(2)}.\\n      </div>\\n    );\\n  }\\n}\\n\")), mdx(\"p\", null, \"To see an example of how light.js is used in a real-world app, see how we built \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/paritytech/fether\"\n  }, \"Parity Fether\"), \" on top of it.\"), mdx(\"h2\", null, \"Next steps\"), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"light.js\"), \" is a small step in the direction of our effort to promote the use of decentralised light clients. We would love to hear feedback from developers, so if you have questions or ideas about this library, make sure to post an issue on the Github repo: \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/paritytech/js-libs/tree/master/packages/light.js\"\n  }, \"https://github.com/paritytech/js-libs/tree/master/packages/light.js\"), \".\"));\n}\n;\nMDXContent.isMDXComponent = true;","timeToRead":3,"excerpt":"This article introduces a new JavaScript library,  light.js , which provides a set of high-level tools to build light-client-efficient Dappsâ€¦"},"allMdx":{"edges":[{"node":{"frontmatter":{"blogTitle":"We just released ink! 4.0!","date_published":"February 08, 2023","image":"/images/qsdh5p9.jpeg","slug":"we-just-released-ink-4-0"}}},{"node":{"frontmatter":{"blogTitle":"Parity Leadership Update","date_published":"October 21, 2022","image":"/images/blog-post.png","slug":"blog/parity-leadership-update/"}}},{"node":{"frontmatter":{"blogTitle":"Transitioning Parity Ethereum to OpenEthereum DAO","date_published":"December 16, 2019","image":"/images/parity-ethereum-openethereum.jpeg","slug":"blog/parity-ethereum-openethereum-dao/"}}}]}},"pageContext":{"slug":"blog/light-js-how-to-build-your-dapp-on-a-light-client/","locale":"en","hrefLang":"en-US","originalPath":"/blog/light-js-how-to-build-your-dapp-on-a-light-client/","dateFormat":"MM/DD/YYYY"}},"staticQueryHashes":["1239077767","1247656359","3280999885","3280999885","4123762078","4185913137","607815487","607815487"]}