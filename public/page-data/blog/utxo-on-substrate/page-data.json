{"componentChunkName":"component---src-components-templates-blog-template-tsx","path":"/blog/utxo-on-substrate/","result":{"data":{"mdx":{"frontmatter":{"author":"Dimitiy Kashitsyn","date_published":"June 18, 2019","image":"/images/utxo-on-substrate-2.png","slug":"blog/utxo-on-substrate/","tags":["Parity Substrate"],"blogTitle":"UTXO on Substrate"},"body":"var _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar _frontmatter = {\n  \"title\": \"index\",\n  \"tags\": [\"Parity Substrate\"],\n  \"author\": \"Dimitiy Kashitsyn\",\n  \"blogTitle\": \"UTXO on Substrate\",\n  \"slug\": \"blog/utxo-on-substrate/\",\n  \"date_published\": \"2019-06-18T04:00:00.000Z\",\n  \"image\": \"/images/utxo-on-substrate-2.png\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Some time ago, Gavin Wood asked me to investigate the possibility of implementing a UTXO chain based on \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://medium.com/r/?url=https%3A%2F%2Fwww.parity.io%2Fsubstrate%2F\"\n  }, \"Substrate\"), \", a new promising blockchain framework made by InvisibleHandLab that is now used as a foundation for \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://medium.com/r/?url=https%3A%2F%2Fpolkadot.network%2F\"\n  }, \"Polkadot\"), \".\"), mdx(\"p\", null, \"We wanted to estimate how flexible Substrate is, and a UTXO chain seemed a good choice to test it out since it\\u2019s very different from what we\\u2019re used to thinking about when implementing Substrate. If it works, then it goes to show that Substrate is indeed pretty flexible and generic; we can be more confident that it would suit almost any other blockchain application.\"), mdx(\"p\", null, \"Similarly to Ethereum, Substrate maintains an amount of available funds as numbers. In some sense, it\\u2019s similar to an ordinary banking system where account balances are represented by numbers and stored somewhere in a database or in a computer memory. This works OK, but it is not necessarily the best or the only possible way to represent such value.\"), mdx(\"p\", null, \"Historically, the first successful cryptocurrency was Bitcoin, which uses an entirely different approach. In Bitcoin, there are no accounts per se, and the balance is not stored as a single number. Instead, available funds are defined based on a set of so-called Unspent Transaction Outputs, abbreviated as UTXO \\u2014 a fancy name for a rather simple idea.\"), mdx(\"h2\", null, \"UTXO in a nutshell\"), mdx(\"p\", null, \"In a nutshell, UTXO is very similar to cash money, or rather, to \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://medium.com/r/?url=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FTraveler%2527s_cheque\"\n  }, \"traveler\\u2019s checks\"), \".\"), mdx(\"p\", null, \"When paying someone in cash you typically think about the total value to be paid, but you use a set of unique and indivisible units (coins or banknotes) to represent that value. For example, if Alice wishes to pay Bob $250 she may do that by giving Bob two notes worth $100 and one note worth $50; or five notes of $50, or any other combination that sums to the desired value.\"), mdx(\"p\", null, \"Each banknote truly is unique. Although there are millions of them with the same value, every banknote is physically unique and has a serial number imprinted on its surface. Usually we do not pay much attention to it and just treat two $100 banknotes as equal when it comes to paying stuff, but this number is essential for banks to control money movement and authenticity checks.\"), mdx(\"p\", null, \"So, each banknote represents a unique and indivisible asset with predefined and fixed value that may be spent only as a whole, i.e., you can\\u2019t tear $100 banknote apart to get two $50 ones. Of course, it is possible to divide the value into smaller units by asking someone for a change, but still, you\\u2019d need to spend your original $100 banknote. In the same manner, when buying a coffee, you fully spend your $10 note, and in return, you get your coffee and some change.\"), mdx(\"p\", null, \"UTXO work in a similar way. To pay someone using Bitcoin, you should already have some unspent assets in your wallet. As with fiat currency, you may combine several UTXO to get a larger value.\"), mdx(\"p\", null, \"Unlike cash money, each UTXO has its owner inscribed. In that sense, it\\u2019s similar to a traveler\\u2019s check because only the check owner is allowed to spend it. This is done by having the unit augmented by the owner signature. The difference is that traveler\\u2019s checks are signed by the owner\\u2019s hand, whereas UTXO uses the asymmetric cryptography and contains a public key of the recipient, not the sender. Finally, banknotes are printed by the government whereas UTXO are created by the sender.\"), mdx(\"p\", null, \"Let\\u2019s recap: a UTXO is a unique and indivisible entity that is associated with its owner by a cryptographic key, has some inherent value, and may be spent only as a whole.\"), mdx(\"h2\", null, \"The goal\"), mdx(\"p\", null, \"In our research, we will be trying to model a blockchain that uses the same principles as Bitcoin to move funds from one owner to another.\"), mdx(\"p\", null, \"However, when reading through the article, please keep in mind that our primary goal is to evaluate Substrate\\u2019s flexibility, not to port Bitcoin in every possible detail. In some cases, the implementation will almost be identical to that of \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://medium.com/r/?url=https%3A%2F%2Fwww.parity.io%2Fbitcoin%2F\"\n  }, \"Parity Bitcoin\"), \", in others \\u2014 not so much. For example, current implementation does \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"not\"), \" support mining and coinbase transactions; it just redistributes the value from a \\u201Cpremined\\u201D set of UTXO that was initialized in the genesis block.\"), mdx(\"p\", null, \"Also, please note that the provided implementation is not at all production-ready. It wasn\\u2019t formally verified and probably has some security or stability issues, so I definitely \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"do\"), \" \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"not\"), \" recommend using it for any critical infrastructure without proper research. However, I would be more than happy if someone were to make this prototype into a working solution.\"), mdx(\"p\", null, \"That being said, let\\u2019s move on to the code.\"), mdx(\"h2\", null, \"Digging in!\"), mdx(\"p\", null, \"First of all, let\\u2019s talk about how Substrate allows you to customize it. As an application programmer, you\\u2019re expected to provide a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"runtime\"), \" \\u2014 a bunch of logic that tells Substrate how to handle the chain and what the business logic should be.\"), mdx(\"p\", null, \"All of this revolves around the idea of a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"State Transition Function\"), \", or STF for short. You can read more of that \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://medium.com/paritytech/substrate-in-a-nutshell-a54cd34c7863\"\n  }, \"in my other article\"), \", but for now let\\u2019s just say that every blockchain can be represented as a function that accepts the current state and a pending transaction, and then yields another state that reflects the changes made after the transaction is applied.\"), mdx(\"p\", null, \"So let\\u2019s say both Alice and Bob have 10 tokens, and then Alice sends 5 tokens to Bob. After this transaction is applied, we expect Alice will now have 5 tokens and Bob will have 15 tokens. If Bob then tries to pay 20 tokens to Claire, that transaction must be considered invalid because, according to the latest chain state, Bob only has 15 tokens.\"), mdx(\"p\", null, \"That\\u2019s exactly what the runtime is meant to do \\u2014 it defines all entities and their relations, validates incoming transactions and alters the state accordingly.\"), mdx(\"p\", null, \"Let\\u2019s start by specifying the data types we\\u2019ll use to define the business logic of our UTXO chain. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Transaction\"), \" type comes first. It represents a single UTXO transaction to be dispatched:\"), mdx(\"script\", {\n    src: \"https://gist.github.com/0x7CFE/23e7545fd86e58430e868ff38804e436.js\"\n  }), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"/// Single transaction to be dispatched\\n#[cfg_attr(feature = \\\"std\\\", derive(Serialize, Deserialize, Debug))]\\n#[derive(PartialEq, Eq, PartialOrd, Ord, Default, Clone, Encode, Decode, Hash)]\\npub struct Transaction {\\n    /// UTXOs to be used as inputs for current transaction\\n    pub inputs: Vec<TransactionInput>,\\n\\n    /// UTXOs to be created as a result of current transaction dispatch\\n    pub outputs: Vec<TransactionOutput>,\\n}\\n\")), mdx(\"p\", null, \"Nothing extraordinary here, just a plain definition that the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Transaction\"), \" is just a bunch of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"inputs\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"outputs\"), \". If you\\u2019re curious, you can \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://medium.com/r/?url=https%3A%2F%2Fgithub.com%2Fparitytech%2Fparity-bitcoin%2Fblob%2Fdadfefe0a47ba79102f5050b81ccbab276261831%2Fchain%2Fsrc%2Ftransaction.rs%23L94\"\n  }, \"compare it\"), \" with the version from Parity Bitcoin to see some similarity. All \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"#[...]\"), \" weirdness above is called \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://medium.com/r/?url=https%3A%2F%2Fdoc.rust-lang.org%2Freference%2Fattributes.html\"\n  }, \"attributes\"), \", and it tells the Rust compiler to implement various things for us, like the comparison operators, hash functions, and serialization routines. You may safely ignore them for now.\"), mdx(\"p\", null, \"I\\u2019ve intentionally left all the comments and attributes to show that even with them being included, the code remains compact and may be written on a few napkins. I think this is a considerable achievement of Substrate, even when compared to Parity Bitcoin that does \\u201Cthe same thing\\u201D in tens of thousands of lines. Much like when writing in JavaScript for the web, you\\u2019re not thinking about the overwhelming complexity of a browser engine or anything beneath, down to the OS level. Instead, you just formulate your business logic in a high-level form and allow the system to do the rest.\"), mdx(\"p\", null, \"Okay, but what about \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TransactionInput\"), \"?\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"/// Single transaction input that refers to one UTXO\\n#[cfg_attr(feature = \\\"std\\\", derive(Serialize, Deserialize, Debug))]\\n#[derive(PartialEq, Eq, PartialOrd, Ord, Default, Clone, Encode, Decode, Hash)]\\npub struct TransactionInput {\\n    /// Reference to an UTXO to be spent\\n    pub parent_output: H256,\\n\\n    /// Proof that transaction owner is authorized to spend referred UTXO\\n    pub signature: Signature,\\n}\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TransactionInput\"), \" aggregates all data needed to spend a single UTXO. First of all, we need a way to refer to some existing UTXO to spend. The easiest way to do so is to use its hash as an identifier. This is a common practice in the world of distributed systems, and it works really well as long as the probability of a hash collision is negligible. For that, we use 256 bit Blake2. The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"parent_output\"), \" field contains such a hash.\"), mdx(\"p\", null, \"As previously mentioned, to spend a UTXO the owner must sign it with a secret key that matches the public key stored in that particular UTXO. This is safe as long as the only person knowing the secret key is the owner. Such proof is stored in the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"signature\"), \" field.\"), mdx(\"p\", null, \"The difference between our implementation and Bitcoin is that we refer to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"parent_output\"), \" directly by its hash, whereas \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://medium.com/r/?url=https%3A%2F%2Fgithub.com%2Fparitytech%2Fparity-bitcoin%2Fblob%2Fdadfefe0a47ba79102f5050b81ccbab276261831%2Fchain%2Fsrc%2Ftransaction.rs%23L19-L44\"\n  }, \"Bitcoin uses\"), \" the hash of a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"transaction\"), \" that produced the UTXO coupled with an index to select a particular entry from the list of transaction\\u2019s outputs. The reason is that Bitcoin is defined in terms of transactions and blocks, whereas we speak in terms of business logic and state transitions. In our case, Substrate transactions are just supplementary entities that facilitate the process and are mostly out of the scope of the business logic. More on that later.\"), mdx(\"p\", null, \"Next goes the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TransactionOutput\"), \" structure that essentially defines the UTXO:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"/// Single transaction output to create upon transaction dispatch\\n#[cfg_attr(feature = \\\"std\\\", derive(Serialize, Deserialize, Debug))]\\n#[derive(Default, PartialEq, Eq, PartialOrd, Ord, Clone, Encode, Decode, Hash)]\\npub struct TransactionOutput {\\n    /// Value associated with this output\\n    pub value: Value,\\n\\n    /// Public key associated with this output. In order to spend this output\\n    /// owner must provide a proof by hashing whole `TransactionOutput` and\\n    /// signing it with a corresponding private key.\\n    pub pubkey: H256,\\n\\n    /// Unique (potentially random) value used to distinguish this\\n    /// particular output from others addressed to the same public\\n    /// key with the same value. Prevents potential replay attacks.\\n    pub salt: u32,\\n}\\n\")), mdx(\"p\", null, \"The purpose of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"value\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pubkey\"), \" fields should already be clear. The only field worth explaining is \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"salt\"), \". This field provides extra entropy to make each UTXO and its hash truly unique.\"), mdx(\"p\", null, \"Imagine a situation where we have a bot that sends 10 tokens to the same recipient every day. For the sake of simplicity, it may use the same destination address, i.e., a recipient\\u2019s public key. Because both \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"value\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"pubkey\"), \" fields would contain the same data, all UTXO created by the bot will look exactly the same and therefore have the same hash.\"), mdx(\"p\", null, \"Without the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"salt\"), \" field, an attacker would be able to remember the signature of the first UTXO spent by the owner and then steal the money by spending all subsequent UTXO before the owner even notices. This is called a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://medium.com/r/?url=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FReplay_attack\"\n  }, \"replay attack\"), \". Also, there is another possibility of a replay attack that is not yet addressed in the source code.\"), mdx(\"p\", null, \"Note, that since the Bitcoin implementation \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://medium.com/r/?url=https%3A%2F%2Fgithub.com%2Fparitytech%2Fparity-bitcoin%2Fblob%2Fdadfefe0a47ba79102f5050b81ccbab276261831%2Fchain%2Fsrc%2Ftransaction.rs%23L19-L44\"\n  }, \"relies on a transaction hash\"), \" to pinpoint the UTXO, it does not suffer from this issue and, hence, does not need \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"salt\"), \". However, that does not mean that replay attacks are not possible in Bitcoin. That\\u2019s why it\\u2019s critical to generate a new Bitcoin address for every incoming transaction.\"), mdx(\"h2\", null, \"The state\"), mdx(\"p\", null, \"So far we have defined all data structures needed to represent a single transaction in memory. But we also need to tell Substrate \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"what\"), \" to store in its state database to support the business logic of the chain by persisting this information over time.\"), mdx(\"p\", null, \"This is done by defining the module storage using \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"decl_storage!\"), \" macro:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"decl_storage! {\\n        trait Store for Module<T: Trait> as Utxo {\\n            /// All valid unspent transaction outputs are stored in this map.\\n            /// Initial set of UTXO is populated from the list stored in genesis.\\n            UnspentOutputs build(|config: &GenesisConfig<T>| {\\n                config.initial_utxo\\n                    .iter()\\n                    .cloned()\\n                    .map(|u| (BlakeTwo256::hash_of(&u), u))\\n                    .collect::<Vec<_>>()\\n            }): map H256 => Option<TransactionOutput>;\\n\\n            /// Total leftover value to be redistributed among authorities.\\n            /// It is accumulated during block execution and then drained\\n            /// on block finalization.\\n            LeftoverTotal: Value;\\n\\n            /// Outputs that are locked\\n            LockedOutputs: map H256 => Option<LockStatus<T>>;\\n        }\\n\\n        add_extra_genesis {\\n            config(initial_utxo): Vec<TransactionOutput>;\\n        }\\n}\\n\")), mdx(\"p\", null, \"It seems to be a large chunk of text, but essentially it defines only three things: a list of unspent outputs, a current amount of leftover value and a list of outputs that are locked and could not be spent unless unlocked. Aside from that, it defines how to populate the chain with an initial set of UTXO during the bootstrap process.\"), mdx(\"p\", null, \"It is important to note that the state storage is very different from block storage.\"), mdx(\"p\", null, \"Block storage is an essential part of every blockchain node and is used to store blocks of that chain. Nowadays, only dedicated archive nodes store the whole chain locally, whereas normal nodes only manage a temporary subset of recent blocks.\"), mdx(\"p\", null, \"On the other hand, state storage is all about business logic. It contains all data needed to reflect the current state of business entities and their relations. In order to validate incoming transactions, the only thing you need to know is the state of all affected parties and amounts of their funds. That\\u2019s why even \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://medium.com/r/?url=https%3A%2F%2Fwww.parity.io%2Fwhat-is-a-light-client%2F\"\n  }, \"light clients\"), \" are able to validate transactions.\"), mdx(\"h2\", null, \"The logic\"), mdx(\"p\", null, \"When we say that Alice receives some funds from Bob, we mean that, according to the rules, a set of UTXO that Bob used to pay Alice must be marked as spent (to prevent Bob from double-spending them later). Then, a new set of UTXO that Bob created for Alice must now be remembered as valid so Alice would be able to spend them afterward.\"), mdx(\"p\", null, \"These rules are the essence of business logic and need to be considered when validating and dispatching incoming transactions.\"), mdx(\"p\", null, \"Let\\u2019s have a look at the entry point to the whole UTXO module:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"decl_module! {\\n    pub struct Module<T: Trait> for enum Call where origin: T::Origin {\\n        /// Dispatch a single transaction and update UTXO set accordingly\\n        pub fn execute(origin, transaction: Transaction) -> Result {\\n            ensure_inherent(origin)?;\\n\\n            let leftover = match Self::check_transaction(&transaction)? {\\n                CheckInfo::MissingInputs(_) => return Err(\\\"all parent outputs must exist and be unspent\\\"),\\n                CheckInfo::Totals { input, output } => input - output\\n            };\\n\\n            Self::update_storage(&transaction, leftover)?;\\n            Self::deposit_event(Event::TransactionExecuted(transaction));\\n\\n            Ok(())\\n        }\\n\\n        /// Handler called by the system on block finalization\\n        fn on_finalise() {\\n            let authorities: Vec<_> = Consensus::authorities().iter().map(|&a| a.into()).collect();\\n            Self::spend_leftover(&authorities);\\n        }\\n    }\\n}\\n\")), mdx(\"p\", null, \"We have two functions defined: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"execute\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"on_finalize\"), \".\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"execute\"), \" function is key to the whole UTXO logic. It accepts a single transaction, checks it, and, if valid, applies the transaction by updating the storage. Finally, it deposits an event signaling that a transaction has just been processed.\"), mdx(\"p\", null, \"The \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"on_finalize\"), \" event handler is called when a single block full of transactions is just formed. By firing that event handler, Substrate allows the runtime to take some action, if needed. We use this handler to redistribute combined leftover value from all transactions among validators that participated in the creation of this block as a reward for their work.\"), mdx(\"h3\", null, \"Transaction checking\"), mdx(\"p\", null, \"In order to validate an incoming transaction, we need to ensure that:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Inputs and outputs are not empty\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"All inputs match to existing, unspent and unlocked outputs\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Each input is used exactly once\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Each output is defined exactly once and has a nonzero value\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Total output value must not exceed total input value\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"New outputs must not collide with existing ones\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Sum of input and output values must not overflow\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Provided signatures are valid\")), mdx(\"p\", null, \"Violation of any of these checks may lead to chain security issues, so it\\u2019s critical to implement them correctly. Luckily, the logic is quite simple and straightforward:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"pub fn check_transaction(transaction: &Transaction) -> CheckResult<'_> {\\n    ensure!(!transaction.inputs.is_empty(), \\\"no inputs\\\");\\n    ensure!(!transaction.outputs.is_empty(), \\\"no outputs\\\");\\n\\n    {\\n        // Collecting inputs into a set where every element is unique.\\n        // If two equal elements are inserted, only one will remain.\\n        let input_set: BTreeMap<_, ()> = transaction\\n            .inputs\\n            .iter()\\n            .map(|input| (input, ()))\\n            .collect();\\n\\n        // Ensuring that the size of original collection and the set are equal.\\n        // If they are not, then due to pigeonhole principle, some entries must\\n        // have been maliciously mentioned several times.\\n        ensure!(\\n            input_set.len() == transaction.inputs.len(),\\n            \\\"each input must be used only once\\\"\\n        );\\n    }\\n\\n    {\\n        let output_set: BTreeMap<_, ()> = transaction\\n            .outputs\\n            .iter()\\n            .map(|output| (output, ()))\\n            .collect();\\n\\n        ensure!(\\n            output_set.len() == transaction.outputs.len(),\\n            \\\"each output must be defined only once\\\"\\n        );\\n    }\\n\\n    let mut total_input: Value = 0;\\n    let mut missing_utxo = Vec::new();\\n    for input in transaction.inputs.iter() {\\n        // Fetch UTXO from the storage\\n        if let Some(output) = <UnspentOutputs<T>>::get(&input.parent_output) {\\n            ensure!(!<LockedOutputs<T>>::exists(&input.parent_output), \\\"utxo is locked\\\");\\n\\n            // Check that we're authorized to spend this UTXO\\n            ensure!(\\n                ed25519_verify(\\n                    input.signature.as_fixed_bytes(),\\n                    input.parent_output.as_fixed_bytes(),\\n                    &output.pubkey\\n                ),\\n                \\\"signature must be valid\\\"\\n            );\\n\\n            // Add the value to the input total\\n            total_input = total_input.checked_add(output.value).ok_or(\\\"input value overflow\\\")?;\\n        } else {\\n            missing_utxo.push(&input.parent_output);\\n        }\\n    }\\n\\n    let mut total_output: Value = 0;\\n    for output in transaction.outputs.iter() {\\n        ensure!(output.value != 0, \\\"output value must be nonzero\\\");\\n\\n        let hash = BlakeTwo256::hash_of(output);\\n        ensure!(!<UnspentOutputs<T>>::exists(hash), \\\"output already exists\\\");\\n\\n        total_output = total_output.checked_add(output.value).ok_or(\\\"output value overflow\\\")?;\\n    }\\n\\n    if missing_utxo.is_empty() {\\n        ensure!(total_input >= total_output, \\\"output value must not exceed input value\\\");\\n        Ok(CheckInfo::Totals { input: total_input, output: total_output })\\n    } else {\\n        Ok(CheckInfo::MissingInputs(missing_utxo))\\n    }\\n}\\n\")), mdx(\"p\", null, \"As you probably noticed, aside from the transaction checking, this function collects some information. Let\\u2019s see its definition:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"/// Result of transaction verification\\npub type CheckResult<'a> = rstd::result::Result<CheckInfo<'a>, &'static str>;\\n\\n/// Information collected during transaction verification\\npub enum CheckInfo<'a> {\\n    /// Combined value of all inputs and outputs\\n    Totals { input: Value, output: Value },\\n\\n    /// Some referred UTXOs were missing\\n    MissingInputs(Vec<&'a H256>),\\n}\\n\\n/// Representation of UTXO value\\npub type Value = u128;\\n\")), mdx(\"p\", null, \"Later it would be shown that we use total \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"input\"), \"s and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"output\"), \"s to calculate the priority of the transaction and an amount of leftover value to be redistributed among validators as a block reward.\"), mdx(\"p\", null, \"However, it makes absolutely no sense to talk about such values if the transaction had failed its verification. Otherwise, an attacker would be able to intentionally craft transactions that would have maximum priority and DoS the chain by flooding the transaction pool and preventing normal transactions from being dispatched. Or it could produce a huge amount of leftover value \\u201Cout of thin air\\u201D to exploit the reward system.\"), mdx(\"p\", null, \"By organizing this data as Rust \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"enum\"), \"s, we prevent accidental misuse since values are available only if a transaction is valid. And vice versa, a list of missing inputs is available only if it was discovered that a transaction refers to some UTXO that are not (yet?) present in the state database. That way it\\u2019s impossible to misuse the API, which is good for readability and chain security.\"), mdx(\"h3\", null, \"State update\"), mdx(\"p\", null, \"If a transaction was verified and proven to be correct then all we need to do is alter the chain state to reflect the changes made by the transaction:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"/// Update storage to reflect changes made by transaction\\nfn update_storage(transaction: &Transaction, leftover: Value) -> Result {\\n    // Calculate new leftover total\\n    let new_total = <LeftoverTotal<T>>::get()\\n        .checked_add(leftover)\\n        .ok_or(\\\"leftover overflow\\\")?;\\n\\n    // Storing updated leftover value\\n    <LeftoverTotal<T>>::put(new_total);\\n\\n    // Remove all used UTXO since they are now spent\\n    for input in &transaction.inputs {\\n        <UnspentOutputs<T>>::remove(input.parent_output);\\n    }\\n\\n    // Add new UTXO to be used by future transactions\\n    for output in &transaction.outputs {\\n        let hash = BlakeTwo256::hash_of(output);\\n        <UnspentOutputs<T>>::insert(hash, output);\\n    }\\n\\n    Ok(())\\n}\\n\")), mdx(\"p\", null, \"Basically, we remove all inputs that are now considered spent and add all new outputs to mark them as available. We also accumulate the leftover value in a temporary storage variable \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"LeftoverTotal\"), \" that will be used during block finalization.\"), mdx(\"h3\", null, \"Block rewards\"), mdx(\"p\", null, \"When a block gets finalized, it is time to reward the nodes that authored the block. This is done by redistributing leftover value collected from all transactions that were included in this block:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"/// Redistribute combined leftover value evenly among authorities\\nfn spend_leftover(authorities: &[H256]) {\\n    let leftover = <LeftoverTotal<T>>::take();\\n    let share_value = leftover / authorities.len() as Value;\\n\\n    if share_value == 0 { return }\\n\\n    for authority in authorities {\\n        let utxo = TransactionOutput {\\n            pubkey: *authority,\\n            value: share_value,\\n            salt: System::block_number() as u32,\\n        };\\n\\n        let hash = BlakeTwo256::hash_of(&utxo);\\n\\n        if !<UnspentOutputs<T>>::exists(hash) {\\n            <UnspentOutputs<T>>::insert(hash, utxo);\\n\\n            runtime_io::print(\\\"leftover share sent to\\\");\\n            runtime_io::print(hash.as_fixed_bytes() as &[u8]);\\n        } else {\\n            runtime_io::print(\\\"leftover share wasted due to hash collision\\\");\\n        }\\n    }\\n}\\n\")), mdx(\"p\", null, \"The logic is pretty simple: we accept a list of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"authorities\"), \" and calculate a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"share_value\"), \" by dividing total \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"leftover\"), \" value by the number of authorities evenly. Then we create one UTXO per author and insert it into \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UnspentOutputs\"), \". We use current block number as a salt value to prevent potential replay attacks that were mentioned above.\"), mdx(\"p\", null, \"We also check that by inserting the reward UTXO to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"UnspentOutputs\"), \" we do not accidentally overwrite some existing UTXO that happened to have the same hash. Such a scenario is extremely rare in practice, but nevertheless, it would be unfortunate if someone would lose his or her UTXO worth of millions just because it was overwritten by a routine reward UTXO.\"), mdx(\"p\", null, \"At first it may look like we\\u2019re creating value out of thin air here, but on second thought, one may realize that the global amount of value would not be increased, since transaction owners explicitly abandoned part of their funds in exchange for priority.\"), mdx(\"p\", null, \"Finally, since every block author knows all the details like the block number, the session key used in that particular era, and, of course, the secret key that matches that session key, the block author will always be able to reconstruct the UTXO, calculate its hash, and claim its reward even without storing that UTXO anywhere.\"), mdx(\"h3\", null, \"UTXO locking\"), mdx(\"p\", null, \"This is where things get different from Bitcoin.\"), mdx(\"p\", null, \"To my knowledge, the Bitcoin specification does not prescribe what information needs to be stored on the disk and how to do that. The only stuff that matters is the Bitcoin protocol itself that is formulated in terms of transactions and blocks. So, each node has to build its own understanding of which UTXO are valid at any given point in blockchain history.\"), mdx(\"p\", null, \"In contrast, our UTXO implementation has the global state database that is agreed upon by \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"all\"), \" participating nodes, by definition. As we already know, it is used to store UTXO status and a temporary amount of leftover value. Since the state database is a part of the consensus, we may rely on its contents in our business logic and be sure that all other nodes will do the same.\"), mdx(\"p\", null, \"But nothing prevents us from storing anything extra. For example, we may add a mapping from a hash of an existing UTXO to a structure that defines the lock status of that UTXO. If UTXO is locked, then it is not allowed to spend it in the usual way:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"#[cfg_attr(feature = \\\"std\\\", derive(Serialize, Deserialize, Debug))]\\n#[derive(Clone, Encode, Decode, Hash)]\\npub enum LockStatus<T: Trait> {\\n    // Referred UTXO is locked\\n    Locked,\\n\\n    // Referred UTXO is locked until specified block\\n    LockedUntil(T::BlockNumber),\\n}\\n\\ndecl_storage! {\\n    trait Store for Module<T: Trait> as Utxo {\\n        ...\\n        \\n        /// Outputs that are locked\\n        LockedOutputs: map H256 => Option<LockStatus<T>>;\\n    }\\n}\\n\")), mdx(\"p\", null, \"Much like the cash that is locked in the safe: you may use it eventually, but no sooner than when you open the safe. It\\u2019s available, just locked.\"), mdx(\"p\", null, \"You may be wondering, why on earth would one need that? You see, in the world of cryptocurrency, there\\u2019s a tendency to replace the old proof-of-waste algorithms with something less greedy and more effective. One possibility is to use the funds themselves as a guarantee that a peer will behave properly.\"), mdx(\"p\", null, \"Basically, one would say: \\u201CI swear that I will act according to the rules. Here\\u2019s my money. Please lock it in a safe place. And if someone will prove that I misbehaved, then my money must be either slashed or distributed among honest participants.\\u201D Of course, if such a person will then wish to get his or her funds back, the network will check that no malicious actions were taken within the last period, and then unlock the funds. Usually, the more funds were locked, the more abilities, vote weight, or income you get. Such systems are generally referred to as a proof-of-stake or PoS for short.\"), mdx(\"p\", null, \"This will work as long as more than two-thirds of the nodes in the network are not malicious and operate according to the protocol. Aside from doing their regular duties, these nodes will also support PoS.\"), mdx(\"p\", null, \"In Ethereum-like blockchains, it may be quite complicated to reason about available funds when dispatching the transactions: every node must ensure that there are enough free funds available, especially, since there may be complex time-dependent contracts.\"), mdx(\"p\", null, \"Interestingly, our UTXO implementation does this in a couple of lines of code. In contrast to Ethereum-like chains, Bitcoin-like chains have their funds already divided in a natural way. We may easily lock a single UTXO and prevent it from being spent until some unlocking condition is met.\"), mdx(\"p\", null, \"It\\u2019s difficult to do the same in Bitcoin because the state database is not part of its original specification; hence, it\\u2019s much harder to reason about which UTXO are locked at any given point in time, not to mention the client compatibility issues.\"), mdx(\"h3\", null, \"Transaction ordering\"), mdx(\"p\", null, \"When talking about business logic of the chain, we mentioned that Substrate does all the dirty work for us, like handling the block storage, performing network interaction and conducting consensus voting. But this is not always the case. We have said that our runtime atomically dispatches one transaction at a time. So, if that transaction were valid, the state would be altered accordingly.\"), mdx(\"p\", null, \"But what happens if two dependent transactions would arrive at the same node in a short period? Real networks are complex and unpredictable. Connectivity issues and sudden topology changes may cause all sorts of effects on the data being transmitted. Notably, messages could be lost, delayed or reordered. The latter fact is especially important for us.\"), mdx(\"p\", null, \"Imagine a situation where we have two transactions, \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"A\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"B\"), \", and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"B\"), \" depends on \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"A\"), \". In the case of UTXO that means that \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"B\"), \" consumes a UTXO that was created by \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"A\"), \". If \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"B\"), \" would arrive prior to \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"A\"), \", we may get a situation where node runtime would not be able to check the validity of a transaction because it refers to a seemingly nonexistent UTXO. Of course, we do know that it exists, it just wasn\\u2019t delivered yet, but the node does not know that. Essentially, it has two options:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Just discard the transaction \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"B\"), \" as invalid. If the original sender would then re-broadcast the transaction, it would still have a chance to be applied, but no sooner than \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"A\"), \" gets dispatched. This solution may work, but it is dirty and ineffective. Moreover, some severe networking issues may lead to a situation where \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"B\"), \" would never be dispatched rendering the whole system useless. We can do better.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Defer the dispatching of the transaction \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"B\"), \" to a point when it would make sense. In our case, we need to wait somehow for \", mdx(\"strong\", {\n    parentName: \"li\"\n  }, \"A\"), \" to be dispatched.\")), mdx(\"p\", null, \"The second option seems to be much more interesting, but how do we do that in practice? By its very design, Substrate knows nothing about runtime internals or the chain\\u2019s business logic. In fact, from its point of view, Substrate \\u201Csees\\u201D our transactions just as opaque byte arrays.\"), mdx(\"p\", null, \"The solution here is to \\u201Cexplain\\u201D to Substrate how to deal with our transactions and how to order them correctly. This is done using dedicated \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TaggedTransactionQueue\"), \" API exposed by a transaction pool to the runtime.\"), mdx(\"p\", null, \"In Substrate, every transaction is associated with two sets of tags: \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"requires\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"provides\"), \". A \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"tag\"), \" is just an arbitrary vector of bytes representing some unique value. The first set describes what tags are required by this transaction, whereas the second set defines tags that are provided by this transaction.\"), mdx(\"p\", null, \"In the case above, we need to link transactions \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"A\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"B\"), \" together by stating that \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"A\"), \" provides some tag and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"B\"), \" consumes the same tag as its requirement. For the sake of simplicity, we may use UTXO hashes as tags.\"), mdx(\"p\", null, \"By traversing transactions and querying for their tags, the transaction pool organizes them in such an order that every transaction will have its requirements met. Those familiar with computer science may realize that this resembles the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://medium.com/r/?url=https%3A%2F%2Fen.wikipedia.org%2Fwiki%2FTopological_sorting\"\n  }, \"topological ordering\"), \".\"), mdx(\"p\", null, \"Sometimes two transactions do not depend on each other but in turn depend on a third transaction. For example, we may have transaction \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"A\"), \" that produces two outputs, and transactions \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"B\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"C\"), \" that spend these two outputs respectively. This will result in having both \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"B\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"C\"), \" depend on \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"A\"), \". Topological ordering states that \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"A\"), \" must be dispatched before \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"B\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"C\"), \", but the order in which to dispatch \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"B\"), \" and \", mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"C\"), \" is not defined. In this case, the transaction pool uses other criteria to prioritize transactions.\"), mdx(\"p\", null, \"The classical solution is to use the amount of leftover value as the priority. The more funds were intentionally left by a transaction owner for authorities, the higher transaction priority will be. Win-win.\"), mdx(\"p\", null, \"Let\\u2019s see how it\\u2019s implemented in our chain:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"impl runtime_api::TaggedTransactionQueue<Block> for Runtime {\\n    fn validate_transaction(tx: <Block as BlockT>::Extrinsic) -> TransactionValidity {\\n        // A bunch of imports\\n        use srml_support::IsSubType;\\n        use runtime_primitives::{\\n            traits::Hash,\\n            transaction_validity::{TransactionLongevity, TransactionPriority, TransactionValidity},\\n        };\\n\\n        // Extrinsics representing UTXO transaction need some special handling\\n        if let Some(&utxo::Call::execute(ref transaction)) = IsSubType::<utxo::Module<Runtime>>::is_aux_sub_type(&tx.function) {\\n            // List of tags to require\\n            let requires;\\n\\n            // Transaction priority to assign\\n            let priority;\\n\\n            match <utxo::Module<Runtime>>::check_transaction(&transaction) {\\n                // Verification failed\\n                Err(e) => {\\n                    runtime_io::print(e);\\n                    return TransactionValidity::Invalid(1);\\n                }\\n\\n                // Transaction was fully verified and is valid\\n                Ok(utxo::CheckInfo::Totals { input, output }) => {\\n                    // All input UTXOs were found, so we consider input conditions to be met\\n                    requires = Vec::new();\\n\\n                    // Priority is based on a transaction fee that is equal to the leftover value\\n                    let max_priority = utxo::Value::from(TransactionPriority::max_value());\\n                    priority = max_priority.min(input - output) as TransactionPriority;\\n                }\\n\\n                // All checks passed except that some of inputs are missing\\n                Ok(utxo::CheckInfo::MissingInputs(missing)) => {\\n                    // Since some referred UTXOs were not found in the storage yet,\\n                    // we tag current transaction as requiring those particular UTXOs\\n                    requires = missing\\n                        .iter()\\n                        .map(|hash| hash.as_fixed_bytes().to_vec())\\n                        .collect();\\n\\n                    // Transaction could not be validated at this point,\\n                    // so we have no sane way to calculate the priority\\n                    priority = 0;\\n                }\\n            }\\n\\n            // Output tags that this transaction provides\\n            let provides = transaction.outputs\\n                .iter()\\n                .map(|output| BlakeTwo256::hash_of(output).as_fixed_bytes().to_vec())\\n                .collect();\\n\\n            return TransactionValidity::Valid {\\n                requires,\\n                provides,\\n                priority,\\n                longevity: TransactionLongevity::max_value(),\\n            };\\n        }\\n\\n        // Fall back to default logic for other extrinsics\\n        Executive::validate_transaction(tx)\\n    }\\n}\\n\")), mdx(\"p\", null, mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TaggedTransactionQueue\"), \" API handles all incoming extrinsics, not just our custom UTXO transactions. This gives a runtime a fine-grained control over the process of extrinsic validation. For example, runtime may perform additional checks, assign custom priority, or simply discard unwanted extrinsics.\"), mdx(\"p\", null, \"Upon its completion, \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"validate_transaction\"), \" function yields the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"TransactionValidity\"), \" structure that contains hints for the transaction pool to order and prioritize the extrinsic:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-rust\"\n  }, \"/// Information on a transaction's validity and, \\n// if valid, on how it relates to other transactions.\\n#[derive(Clone, PartialEq, Eq, Encode)]\\n#[cfg_attr(feature = \\\"std\\\", derive(Debug))]\\npub enum TransactionValidity {\\n    /// Transaction is invalid. Details are described by the error code.\\n    Invalid(i8),\\n    /// Transaction is valid.\\n    Valid {\\n        /// Priority determines the ordering of two transactions that have all\\n        /// their dependencies (required tags) satisfied.\\n        priority: TransactionPriority,\\n        \\n        /// A non-empty list signifies that some other transactions which provide\\n        /// given tags are required to be included before that one.\\n        requires: Vec<TransactionTag>, \\n        \\n        /// A list of tags this transaction provides. Successfully importing the transaction\\n        /// will enable other transactions that depend on (require) those tags to be included as well.\\n        /// Provided and required tags allow Substrate to build a dependency graph of transactions\\n        /// and import them in the right (linear) order.\\n        provides: Vec<TransactionTag>,\\n        \\n        /// Longevity describes minimum number of blocks the validity is correct.\\n        /// After this period transaction should be removed from the pool or revalidated.\\n        longevity: TransactionLongevity,\\n        \\n        /// By setting `false` here the transaction will still be considered for\\n        /// including in blocks that are authored on the current node, but will\\n        /// never be sent to other peers.\\n        propagate: bool,\\n    },\\n    /// Transaction validity can't be determined.\\n    Unknown(i8),\\n}\\n\")), mdx(\"p\", null, \"In order to implement our logic we need to select only the extrinsics that correspond to UTXO transactions. This is done using the \\u201Cmagic\\u201D call to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"IsSubType::is_aux_sub_type(&tx.function)\"), \" function parametrized by the module name \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"utxo::Module<Runtime>\"), \". Upon success, this function returns a type that contains a deserialized call to our \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"execute\"), \" method along with a \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Transaction\"), \" instance \\u2014 everything we need to reason about transaction tags and priority.\"), mdx(\"p\", null, \"The rest is just a logic that assigns tags and priority depending on \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"check_transaction\"), \" result:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If transaction was fully verified, i.e., all incoming UTXO were found in the storage and all signatures were proven to be correct, then we populate \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"provides\"), \" tags only, while keeping \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"requires\"), \" list empty. That way we tell the transaction pool that the transaction does not depend on anything and is ready for immediate dispatch with the priority calculated as a difference between its \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"input\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"output\"), \" values.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If transaction was verified, but has some of its inputs missing, then we populate the \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"requires\"), \" and \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"provides\"), \" lists, allowing the transaction pool to order the transaction. Later, the transaction pool will call us again to re-validate the transaction, when its requirements would be met.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"If verification was failed (for example, if one of the signatures happened to be invalid), then we abort the transaction dispatch by returning \", mdx(\"inlineCode\", {\n    parentName: \"li\"\n  }, \"TransactionValidity::Invalid\"), \". The transaction pool will discard the extrinsic and remember our decision, so that all subsequent copies that may be received from other peers will be discarded as well.\")), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Note:\"), \" current implementation assigns maximum value to the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"longevity\"), \" field. That way transaction pool will hold pending transactions in its queue indefinitely. This is OK for a proof-of-concept implementation, but the proper solution must assign something more clever.\"), mdx(\"p\", null, \"For example, we may wait for several block periods for a transaction to have its requirements met. If, after all this time, the transaction still wasn\\u2019t dispatched, then we treat it as malformed and invalid, and discard as usual.\"), mdx(\"p\", null, \"Without such a timeout, a malicious person may flood our node with transactions that depend on random non-existing inputs. Since we have no sane way to discard such transactions early, this may effectively DoS our node by filling its transaction pool with garbage.\"), mdx(\"h2\", null, \"The result\"), mdx(\"p\", null, \"This article already grew too large to cover everything related to initial chain configuration and bootstrap process. So let\\u2019s just see what will happen if we\\u2019d try executing our chain.\"), mdx(\"p\", null, \"If you like, you may try implementing the UTXO chain yourself. Based on my \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://medium.com/r/?url=https%3A%2F%2Fgithub.com%2F0x7CFE%2Fsubstrate-node-template%2Ftree%2Futxo\"\n  }, \"prototype implementation\"), \", Nicole Zhu together with Amar Singh prepared a \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://medium.com/r/?url=https%3A%2F%2Fgithub.com%2Fnczhu%2Futxo-workshop\"\n  }, \"UTXO workshop repository\"), \" where you may find everything needed from code stubs to detailed instructions. Also check out \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://medium.com/r/?url=https%3A%2F%2Fdocs.substrate.dev%2F\"\n  }, \"the Substrate developer hub\"), \".\"), mdx(\"p\", null, \"First of all, we need to build our Substrate node with the UTXO runtime. I am assuming you are already familiar with the Rust ecosystem and know how to build stuff. If you\\u2019re unfamiliar with Rust, I suggest you have a look at the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://medium.com/r/?url=https%3A%2F%2Fwww.rust-lang.org%2F\"\n  }, \"Rust language site\"), \".\"), mdx(\"p\", null, \"Next, we need to \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://medium.com/r/?url=https%3A%2F%2Fpolkadot.js.org%2Fapps%2F%23%2Fsettings\"\n  }, \"configure the UI\"), \" to connect to \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"Local Node\"), \" instead of the default. We also need to \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://medium.com/r/?url=https%3A%2F%2Fpolkadot.js.org%2Fapps%2F%23%2Fsettings%2Fdeveloper\"\n  }, \"tell the UI\"), \" how to read into our custom UTXO types. This is done by providing a JSON file that has a mapping from our custom types to the core types that the UI is already familiar with:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-json\"\n  }, \"{\\n    \\\"Value\\\": \\\"u128\\\",\\n    \\\"LockStatus\\\": \\\"u32\\\",\\n    \\\"TransactionInput\\\": {\\n        \\\"parent_output\\\": \\\"Hash\\\",\\n        \\\"signature\\\": \\\"Signature\\\"\\n    },\\n    \\\"TransactionOutput\\\": {\\n        \\\"value\\\": \\\"Value\\\",\\n        \\\"pubkey\\\": \\\"Hash\\\",\\n        \\\"salt\\\": \\\"u64\\\"\\n    },\\n    \\\"Transaction\\\": {\\n        \\\"inputs\\\": \\\"Vec<TransactionInput>\\\",\\n        \\\"outputs\\\": \\\"Vec<TransactionOutput>\\\"\\n    }\\n}\\n\")), mdx(\"p\", null, \"The rest of the setup instructions may be found in \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://medium.com/r/?url=https%3A%2F%2Fgithub.com%2Fnczhu%2Futxo-workshop%2Fblob%2Fmaster%2FREADME.md\"\n  }, \"the workshop\\u2019s Readme file\"), \".\"), mdx(\"p\", null, \"Dev chain has its genesis block compiled-in. In our case it contains the only UTXO that gives Alice a ridiculously huge amount of \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0xff...f\"), \" tokens.\"), mdx(\"p\", null, \"Let\\u2019s check that Alice indeed own that funds. To do that we need to calculate the hash of the UTXO which happens to be \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0xf414d3\\u20262393b2\"), \". If the chain was initialized correctly we should see something like this:\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/images/utxo-image-five.png\",\n    \"alt\": null\n  })), mdx(\"p\", null, \"Let\\u2019s now ask Alice to spend part of that value and send, say, 100 tokens to Bob. We do that by submitting an inherent extrinsic via the UI:\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/images/utxo-image-four.png\",\n    \"alt\": null\n  })), mdx(\"p\", null, \"We submit the extrinsic by providing its serialized hex-encoded version. When we\\u2019re ready, we click the \\u201CSubmit Inherent\\u201D button and verify that it was parsed by the system correctly:\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/images/utxo-image-three.png\",\n    \"alt\": null\n  })), mdx(\"p\", null, \"Note the \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"transaction\"), \" contents. We see that the transaction mentions \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"0xf414d3\\u20262393b2\"), \" as its \", mdx(\"inlineCode\", {\n    parentName: \"p\"\n  }, \"parent_output \"), \"and 100 tokes as desired.\"), mdx(\"p\", null, \"If all goes well we should see the popups appearing in the upper right corner that will notify us about transaction progress:\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/images/utxo-image-two.png\",\n    \"alt\": null\n  })), mdx(\"p\", null, \"Finally, we can check that the transaction was indeed included to the block:\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/images/utxo-image-one.png\",\n    \"alt\": null\n  })), mdx(\"p\", null, \"Apparently it worked!\"), mdx(\"p\", null, \"Please note that during our research we said nothing about how to find peers and do network communication, how to author and store blocks, how to reach consensus with other peers, etc. We only said what \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"we\"), \" want to have in terms of \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"our\"), \" business logic. The rest was automagically done by Substrate.\"), mdx(\"h2\", null, \"Conclusion\"), mdx(\"p\", null, \"In the world of software engineering, there is a difference between libraries and frameworks.\"), mdx(\"p\", null, \"A library is a rather independent piece of code that deals with a limited problem set and is usually not enough to support the solution on its own. As a developer, you typically need to combine several libraries and write your own glue code to get things working.\"), mdx(\"p\", null, \"Frameworks, on the other hand, are much more complex and usually cover all aspects of the software development process from the start to the end. By providing ready solutions and suggesting effective design patterns, frameworks allow you to deliver your project with a minimum time investment.\"), mdx(\"p\", null, \"Frameworks give you great power but can become burdensome if your project stops fitting into a framework\\u2019s philosophy. You can test the quality and flexibility of a framework\\u2019s design by seeing how hard it is to \\u201Cbend the rules\\u201D of the framework and do things that seem to be \\u201Cout of scope\\u201D. Usually, the more out-of-scope your solution is, the harder it is to match the framework\\u2019s \\u201Cflow\\u201D.\"), mdx(\"p\", null, \"In that sense, Substrate looks very promising. As we\\u2019ve seen with this UTXO implementation, we were able to use Substrate to implement a solution that wasn\\u2019t originally anticipated by the Substrate\\u2019s design. But still, the implementation was mostly seamless which is a good sign.\"), mdx(\"p\", null, \"The most interesting thing is that all that flexibility didn\\u2019t affect our experience in a negative way. Implementing the UTXO chain wasn\\u2019t terribly different from other demo projects like \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://medium.com/r/?url=https%3A%2F%2Fshawntabrizi.com%2Fsubstrate-collectables-workshop%2F%23%2FREADME\"\n  }, \"Shawn\\u2019s Collectables\"), \" or \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://medium.com/r/?url=https%3A%2F%2Fsubstrate.dev%2Fdocs%2Fen%2Ftutorials%2Fcreating-your-first-substrate-chain\"\n  }, \"Gavin\\u2019s coin flip game\"), \". All that makes me optimistic about the future of Substrate as a framework and as an ecosystem. Stay tuned!\"));\n}\n;\nMDXContent.isMDXComponent = true;","timeToRead":19,"excerpt":"Some time ago, Gavin Wood asked me to investigate the possibility of implementing a UTXO chain based on  Substrate , a new promising…"},"allMdx":{"edges":[{"node":{"frontmatter":{"blogTitle":"We just released ink! 4.0!","date_published":"February 08, 2023","image":"/images/qsdh5p9.jpeg","slug":"we-just-released-ink-4-0"}}},{"node":{"frontmatter":{"blogTitle":"Parity Leadership Update","date_published":"October 21, 2022","image":"/images/blog-post.png","slug":"blog/parity-leadership-update/"}}},{"node":{"frontmatter":{"blogTitle":"Transitioning Parity Ethereum to OpenEthereum DAO","date_published":"December 16, 2019","image":"/images/parity-ethereum-openethereum.jpeg","slug":"blog/parity-ethereum-openethereum-dao/"}}}]}},"pageContext":{"slug":"blog/utxo-on-substrate/","locale":"en","hrefLang":"en-US","originalPath":"/blog/utxo-on-substrate/","dateFormat":"MM/DD/YYYY"}},"staticQueryHashes":["1239077767","1247656359","3280999885","3280999885","4123762078","4185913137","607815487","607815487"]}