{"componentChunkName":"component---src-components-templates-blog-template-tsx","path":"/blog/parity-stepping-up-the-security-model-1-a-modular-approach-to-transaction-signing/","result":{"data":{"mdx":{"frontmatter":{"author":"InvisibleHandLab","date_published":"May 30, 2016","image":"","slug":"blog/parity-stepping-up-the-security-model-1-a-modular-approach-to-transaction-signing/","tags":["Security"],"blogTitle":"Parity: Stepping Up the Security Model 1: A modular approach to transaction signing"},"body":"var _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar _frontmatter = {\n  \"title\": \"index\",\n  \"tags\": [\"Security\"],\n  \"author\": \"InvisibleHandLab\",\n  \"blogTitle\": \"Parity: Stepping Up the Security Model 1: A modular approach to transaction signing\",\n  \"slug\": \"blog/parity-stepping-up-the-security-model-1-a-modular-approach-to-transaction-signing/\",\n  \"date_published\": \"2016-05-30T04:00:00.000Z\",\n  \"image\": \"\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"A security flaw in Geth / Mist has been attracting some attention recently mainly because of the size of the loss of Ether suffered by the user affected. Almost 100,000 USD was lost after he sent a transaction to theDAO using a Geth client whose settings had been changed from the default.\"), mdx(\"p\", null, \"The official response was: \\u2018SFYL but don\\u2019t mess with the settings\\u2019 - rather disappointing given the fundamental issue was not that the user compromised himself with his setup (though this was extremely unfortunate) but, that the process of sending a transaction to the client via IPC unlocks the account for two seconds. Claiming that because the attack vector demonstrated required some contrivance to enable means that the weakness in the system is not a weakness is simply wrong.\"), mdx(\"p\", null, \"The Geth team have acknowledged this with a hotfix which adds a new RPC method personal_signAndSendTransaction which does not unlock the account and instead requires you to send the password and transaction data in one call. This is again not ideal - in this case, it means that browser based \\xD0apps (like Augur, Gnosis, MakerOTC etc..) would need you to input your password into their front end requiring you to trust the code being executed in the browser to not steal this.\"), mdx(\"p\", null, \"Parity is being built specifically to serve and operate \\xD0apps natively inside your browser - so how are we going to make sure that we never need to leave access to our private keys unlocked, and never need to give our password to \\xD0app front-ends?\"), mdx(\"p\", null, \"The first thing we have done is to make sure that each \\xD0app front-end has its own RPC endpoint meaning that CORS is not required. Secondly, we have re-imagined and re-designed the API used by applications to speak to the client - essentially splitting it into two parts. The first portion will be a normal public API; these are the \\u2018safe\\u2019 functions available to \\xD0apps like querying storage or watching for changes to log filters. They will be available directly from Parity through the normal RPC server.\"), mdx(\"p\", null, \"However, the second portion of the API will be an API available only through the Trusted Signer System. This and only this will be able to sign transactions using the user\\u2019s private keys and it will do so without exposing passwords to \\xD0app front ends - or leaving accounts unlocked for arbitrary periods.\"), mdx(\"p\", null, \"This Trusted Signer will always operate from a fully isolated context; one that is not available to the \\xD0app (or wallet, for that matter). Crucially, this will be an operating system process that is not that which is requesting the transaction signing event. Furthermore, it is designed to be modular, meaning it will be possible to switch out EthCore\\u2019s hardened key management and signing module with some other means, for example, a hardware wallet or a 2-factor authentication system.\"), mdx(\"p\", null, \"The solution to the Mist hack problem will always be to isolate the process of signing transactions from \\xD0apps, keeping the security-sensitive processes both insulated from attack and well under the control of the user. Only by doing this can you keep your keys, and the increasing shades of value they represent, safe and secure.\"), mdx(\"p\", null, \"However, this is insufficient protection for users if they are either unaware of the dangers of signing transactions or that they succumb to the dreaded \\u201C\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Alarm_fatigue\"\n  }, \"Alarm Fatigue\"), \"\\u201D that repeatedly entering passwords to use \\xD0apps that can ruin the UX and make security measures redundant. This is why Ethcore\\u2019s Trusted Signer System will protect users from malicious \\xD0apps using our Semantic Transaction Processing System designed to expose the meaning behind every transaction sent.\"), mdx(\"p\", null, \"Coming soon:\"), mdx(\"p\", null, \"Parity: Stepping Up the Security Model 2: The Semantic Transaction Processing System\"));\n}\n;\nMDXContent.isMDXComponent = true;","timeToRead":2,"excerpt":"A security flaw in Geth / Mist has been attracting some attention recently mainly because of the size of the loss of Ether suffered by theâ€¦"},"allMdx":{"edges":[{"node":{"frontmatter":{"blogTitle":"We just released ink! 4.0!","date_published":"February 08, 2023","image":"/images/qsdh5p9.jpeg","slug":"we-just-released-ink-4-0"}}},{"node":{"frontmatter":{"blogTitle":"Parity Leadership Update","date_published":"October 21, 2022","image":"/images/blog-post.png","slug":"blog/parity-leadership-update/"}}},{"node":{"frontmatter":{"blogTitle":"Transitioning Parity Ethereum to OpenEthereum DAO","date_published":"December 16, 2019","image":"/images/parity-ethereum-openethereum.jpeg","slug":"blog/parity-ethereum-openethereum-dao/"}}}]}},"pageContext":{"slug":"blog/parity-stepping-up-the-security-model-1-a-modular-approach-to-transaction-signing/","locale":"en","hrefLang":"en-US","originalPath":"/blog/parity-stepping-up-the-security-model-1-a-modular-approach-to-transaction-signing/","dateFormat":"MM/DD/YYYY"}},"staticQueryHashes":["1239077767","1247656359","3280999885","3280999885","4123762078","4185913137","607815487","607815487"]}