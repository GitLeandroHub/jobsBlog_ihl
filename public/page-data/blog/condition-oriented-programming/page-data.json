{"componentChunkName":"component---src-components-templates-blog-template-tsx","path":"/blog/condition-oriented-programming/","result":{"data":{"mdx":{"frontmatter":{"author":"Gavin Wood","date_published":"June 27, 2016","image":"","slug":"blog/condition-oriented-programming/","tags":["Parity Ethereum"],"blogTitle":"Condition-Oriented Programming"},"body":"var _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar _frontmatter = {\n  \"title\": \"index\",\n  \"tags\": [\"Parity Ethereum\"],\n  \"author\": \"Gavin Wood\",\n  \"blogTitle\": \"Condition-Oriented Programming\",\n  \"slug\": \"blog/condition-oriented-programming/\",\n  \"date_published\": \"2016-06-27T04:00:00.000Z\",\n  \"image\": \"\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Condition-Orientated Programming (COP) is a hybrid approach between functional and imperative programming. Done properly it is a tool in your arsenal for writing safe, secure contracts. It helps make your contract code comprehensively auditable and - loosely speaking - informally provable to have correct run-time operation.\"), mdx(\"p\", null, \"COP is not language specific; it is more of a loose methodology than particular syntax. However, with its function modifiers and events, it is particularly well-suited to the Solidity language.\"), mdx(\"p\", null, \"Simply put, COP has just one main aim:\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Function bodies should have no conditional paths.\")), mdx(\"p\", null, \"Or alternatively:\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Never mix transitions with conditions.\")), mdx(\"p\", null, \"This may seem like a difficult goal to achieve for an imperative language, since conditional paths are how you achieve the rich state-transitions which allow interesting operational dynamics. To achieve it, we try to split all conditions apart from the state-transitions that they guard. We name each independently and combine to form real functions.\"), mdx(\"p\", null, \"The problem with such conditional paths within transition logic is that they add conceptual non-linearity over state semantics. Potential bugs hide when the programmer believes a conditional (and thus the state it projects onto) means one thing when in fact it means something subtly different.\"), mdx(\"p\", null, \"A single-level conditional is bad enough, but when multi-level conditionals are introduced, the complexity (i.e. the paths which the programmer must consider in all states of the world) increases exponentially and it quickly becomes impossible to reason about the entire contract's state transitions without formal tools not generally available.\"), mdx(\"p\", null, \"COP addresses this by requiring the programmer to explicitly enumerate all such conditionals. Logic becomes flattened into non-conditional state-transactions. The condition fragments can then be properly documented, reused, reasoned-about and attributed with requirements and implications. Essentially, COP uses pre-conditions as a first-class citizen in programming.\"), mdx(\"h2\", null, \"HOW IT WORKS\"), mdx(\"p\", null, \"If you have already used Solidity, the chances are that you inadvertently flirted with COP already. Let's look at a simple token contract:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-sol\"\n  }, \"contract Token {\\n    // The balance of everyone\\n    mapping (address => uint) public balances;\\n\\n    // Constructor - we're a millionaire!\\n    function Token() {\\n        balances[msg.sender] = 1000000;\\n    }\\n\\n    // Transfer `_amount` tokens of ours to `_dest`.\\n    function transfer(uint _amount, address _dest) {\\n        balances[msg.sender] -= _amount;\\n        balances[_dest] += _amount;\\n    }\\n}\\n\")), mdx(\"p\", null, \"The astute reader will realise there is a bug here: the transfer function doesn't ensure that the sender has enough in their account. The normal imperative-language fix for this would be to introduce an if statement:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-solidity\"\n  }, \"function transfer(uint _amount, address _dest) {\\n    if (balances[msg.sender] >= _amount) {\\n        balances[msg.sender] -= _amount;\\n        balances[_dest] += _amount;\\n    }\\n}\\n\")), mdx(\"p\", null, \"or perhaps:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-solidity\"\n  }, \"function transfer(uint _amount, address _dest) {\\n    if (balances[msg.sender] >= _amount) {\\n        balances[msg.sender] -= _amount;\\n        balances[_dest] += _amount;\\n    }\\n}\\n\")), mdx(\"p\", null, \"However both of these solutions rather miss the point of COP; we're muddling the implementation (which ever one we choose) with the meaning, which remains the same in both cases: that the executing account msg.sender, should have a balance of at least amount. As a COP coder, we understand this problem perfectly since both solutions break our fundamental rule:\"), mdx(\"p\", null, mdx(\"strong\", {\n    parentName: \"p\"\n  }, \"Function bodies should have no conditional paths.\")), mdx(\"p\", null, \"So in COP, we rather abstract the condition (balances\", \"[\", \"msg.sender\", \"]\", \" >= amount) and create a function modifier:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-solidity\"\n  }, \"modifier only_with_at_least(uint x) { if (balances[msg.sender] >= x) _ }\\n\")), mdx(\"p\", null, \"This piece of code fundamentally abstracts the notion of \\\"executing account has a balance of at least some particular amount\\\". With it in place, we no longer need to think in terms of conditionals, and most importantly, we don't need to mix pre-condition logic with state-transition logic. This allows a far greater scope for human-understandable analysis of state-transitions.\"), mdx(\"p\", null, \"Here's the new transfer function:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-solidity\"\n  }, \"function transfer(uint _amount, address _dest) only_with_at_least(_amount) {\\n    balances[msg.sender] -= _amount;\\n    balances[_dest] += _amount;\\n}\\n\")), mdx(\"h2\", null, \"ABSTRACTION AND REUSE\"), mdx(\"p\", null, \"Suppose we have another function, which allows anyone with a balance more than 1000 to vote on some issue. We'll assume for now that voting is just a case of setting the value of an address-indexed mapping.\"), mdx(\"p\", null, \"In our old scheme of things, we'd have a function like this:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-solidity\"\n  }, \"function vote(uint _opinion) {\\n    if (balances[msg.sender] >= 1000) {\\n        votes[msg.sender] = _opinion;\\n    }\\n}\\n\")), mdx(\"p\", null, \"Added to our old codebase, we would now have two similar-meaning conditionals. In principle, we would like to have only one such conditional, audited and documented once but used twice. With COP that's exactly what we do:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-solidity\"\n  }, \"function vote(uint _opinion) only_when_at_least(1000) {\\n    votes[msg.sender] = _opinion;\\n}\\n\")), mdx(\"p\", null, \"This makes our vote function substantially more readable and allows us to reuse important guard-logic, minimizing our potential attack surface.\"), mdx(\"h2\", null, \"MORE COMPLEX TRANSITIONS\"), mdx(\"p\", null, \"By discouraging conditional paths from our state-transitions, we limit the complexity of our state-transitions. This hugely helps with auditing since it allows us apply the divide and conquer strategy to program logic analysis and independently check the logic of state transitions from the conditional logic on which they are gated. However sometimes the state transition itself includes gated logic internally.\"), mdx(\"p\", null, \"Following on the voting example, suppose we extend the transfer function so that we ensure that any new, reduced, balance has no vote.\"), mdx(\"p\", null, \"In the traditional, imperative, way we would simply place a conditional near the balance reduction code:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-solidity\"\n  }, \"function transfer(uint _amount, address _dest) {\\n    if (balances[msg.sender] >= _amount) {\\n        balances[msg.sender] -= _amount;\\n        balances[_dest] += _amount;\\n        if (balances[msg.sender] < 1000) {\\n            votes[msg.sender] = 0; // Clear their vote.\\n        }\\n    }\\n}\\n\")), mdx(\"p\", null, \"However, this rather goes against the grain of COP. However we cannot address this directly with a new function modifier since there is no obvious function to modify; we actually wish to place the guard within an internal scope of transfer. In this case (at least with Solidity), we rather create a new (inline) function:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-solidity\"\n  }, \"function clear_undeserved_vote(account _who)\\n    only_with_under(1000) only_when_voted {\\n    delete votes[_who];\\n}\\n\")), mdx(\"p\", null, \"Note inline is not yet available in Solidity; we would use it here whenever it be available. This function relies on two modifiers which are easily coded (and audited):\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-solidity\"\n  }, \"modifier only_with_under(uint x) { if (balances[msg.sender] < x) _ }\\nmodifier only_when_voted { if (votes[msg.sender] != 0) _ }\\n\")), mdx(\"p\", null, \"We can then use this function within our transfer function:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-solidity\"\n  }, \"function transfer(uint _amount, address _dest) only_with_at_least(_amount) {\\n    balances[msg.sender] -= _amount;\\n    balances[_dest] += _amount;\\n    clear_undeserved_vote();\\n}\\n\")), mdx(\"h2\", null, \"CONCLUSION\"), mdx(\"p\", null, \"The main part of our final contract has changed from:\"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-solidity\"\n  }, \"contract Token\\n    {\\n    //...\\n\\n    function transfer(uint _amount, address _dest) {\\n        if (balances[msg.sender] >= _amount) {\\n            balances[msg.sender] -= _amount;\\n            balances[_dest] += _amount;\\n            if (balances[msg.sender] < 1000) {\\n                votes[msg.sender] = 0;    // Clear their vote.\\n            }\\n        }\\n    }\\n\\n    function vote(uint _opinion) {\\n        if (balances[msg.sender] >= 1000) {\\n            votes[msg.sender] = _opinion;\\n        }\\n    }\\n}\\n\")), mdx(\"p\", null, \"To the new: \"), mdx(\"pre\", null, mdx(\"code\", {\n    parentName: \"pre\",\n    \"className\": \"language-solidity\"\n  }, \"contract Token\\n    {\\n    //...\\n\\n    modifier only_with_at_least(uint x) { if (balances[msg.sender] >= x) _ }\\n    modifier only_with_under(uint x) { if (balances[msg.sender] < x) _ }\\n    modifier only_when_voted { if (votes[msg.sender] != 0) _ }\\n\\n    function clear_undeserved_vote(account _who)\\n        only_with_under(1000) only_when_voted {\\n        delete votes[_who];\\n    }\\n\\n    function transfer(uint _amount, address _dest)\\n        only_with_at_least(_amount) {\\n        balances[msg.sender] -= _amount;\\n        balances[_dest] += _amount;\\n        clear_undeserved_vote();\\n    }\\n\\n    function vote(uint _opinion) only_when_at_least(1000) {\\n        votes[msg.sender] = _opinion;\\n    }\\n}\\n\")), mdx(\"p\", null, \"The code we have is somewhat longer, however it has now forced the coder to document the internals, encouraging them to place weight on considering the conditions in isolation and abstracts the important parts to ensure that no copy/paste bugs creep in. The execution structure is flat, easing the conceptual baggage that the auditor must consider. It can be documented and audited, piece-by-piece in a comprehensive and methodical fashion. And, even if left undocumented, it is far more comprehensible, with the named conditions over the original version which muddles them into the transition logic.\"), mdx(\"p\", null, \"Being rather verbose, COP certainly won\\u2019t be to everyone\\u2019s taste. And without certain language support, it can become somewhat unwieldy with large contracts. However, for small and medium-size contracts it provides the programmer and auditor with a clear path to enlightenment that can otherwise be difficult to attain.\"), mdx(\"p\", null, \"In the next article in this series I\\u2019ll take a \\\"real-world\\\" contract, coded in COP style, and show how it can be broken down, documented and informally demonstrated to be correct.\"), mdx(\"p\", null, \"(Note: This is a report of an article originally placed on Medium.)\"));\n}\n;\nMDXContent.isMDXComponent = true;","timeToRead":4,"excerpt":"Condition-Orientated Programming (COP) is a hybrid approach between functional and imperative programming. Done properly it is a tool in…"},"allMdx":{"edges":[{"node":{"frontmatter":{"blogTitle":"We just released ink! 4.0!","date_published":"February 08, 2023","image":"/images/qsdh5p9.jpeg","slug":"we-just-released-ink-4-0"}}},{"node":{"frontmatter":{"blogTitle":"Parity Leadership Update","date_published":"October 21, 2022","image":"/images/blog-post.png","slug":"blog/parity-leadership-update/"}}},{"node":{"frontmatter":{"blogTitle":"Transitioning Parity Ethereum to OpenEthereum DAO","date_published":"December 16, 2019","image":"/images/parity-ethereum-openethereum.jpeg","slug":"blog/parity-ethereum-openethereum-dao/"}}}]}},"pageContext":{"slug":"blog/condition-oriented-programming/","locale":"en","hrefLang":"en-US","originalPath":"/blog/condition-oriented-programming/","dateFormat":"MM/DD/YYYY"}},"staticQueryHashes":["1239077767","1247656359","3280999885","3280999885","4123762078","4185913137","607815487","607815487"]}