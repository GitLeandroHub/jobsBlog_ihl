{"componentChunkName":"component---src-components-templates-blog-template-tsx","path":"/blog/substrate-in-a-nutshell/","result":{"data":{"mdx":{"frontmatter":{"author":"Dimitiy Kashitsyn","date_published":"October 04, 2018","image":"/images/substrate-nuthsell-blog-hero.png","slug":"blog/substrate-in-a-nutshell/","tags":["Parity Substrate"],"blogTitle":"Substrate in a nutshell"},"body":"var _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar _frontmatter = {\n  \"title\": \"index\",\n  \"tags\": [\"Parity Substrate\"],\n  \"author\": \"Dimitiy Kashitsyn\",\n  \"blogTitle\": \"Substrate in a nutshell\",\n  \"slug\": \"blog/substrate-in-a-nutshell/\",\n  \"date_published\": \"2018-10-04T04:00:00.000Z\",\n  \"image\": \"/images/substrate-nuthsell-blog-hero.png\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Today we\\u2019ll be talking about \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://parity.io/substrate/\"\n  }, \"Substrate\"), \", a library that can help you build your own custom blockchain. Substrate is created by \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://parity.io/\"\n  }, \"InvisibleHandLab\"), \" and provides the basis for \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://polkadot.network/\"\n  }, \"Polkadot\"), \".\"), mdx(\"h2\", null, \"What is a substrate?\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"A substance or layer that underlies something, or on which some process occurs (Oxford Dictionary).\")), mdx(\"p\", null, \"As the name suggests, Substrate may be used to grow or build something on it. In our case, we can build blockchains, or, in the case of Polkadot, a whole family of blockchains.\"), mdx(\"h2\", null, \"Why would I need Substrate?\"), mdx(\"p\", null, \"Software is all about abstractions.\"), mdx(\"p\", null, \"The history of computer science shows that we\\u2019re constantly getting more and more abstract: from discrete logic to integrated circuits and CPUs; from machine code to assembly, from assembly to C, then to C++, Rust, Haskell and so on.\"), mdx(\"p\", null, \"The same happens with programming APIs. For example, these days almost no one writes for web in plain HTML.\"), mdx(\"p\", null, mdx(\"em\", {\n    parentName: \"p\"\n  }, \"\\u201CEvery problem may be solved by introducing yet another layer of abstraction. Except for a problem of too many abstraction layers\\u2026 for that we invent frameworks.\\u201D \\u2014 rephrasing of\"), \" \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://en.wikipedia.org/wiki/Fundamental_theorem_of_software_engineering\"\n  }, mdx(\"em\", {\n    parentName: \"a\"\n  }, \"Andrew Koenig\\u2019s FTSE\")), mdx(\"em\", {\n    parentName: \"p\"\n  }, \".\")), mdx(\"p\", null, \"Each abstraction level tries to solve a particular problem. So what problem was Substrate created to solve? It turns out that, before you start implementing your brand new blockchain solution, you have a lot of topics to think about:\"), mdx(\"ul\", null, mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Why on earth would one need yet another blockchain?!\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Various crypto primitives: encryption, signatures, RNG\\xB9, etc.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Consensus algorithms and fault tolerance voting.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Proof of Waste, Proof of Stake, Proof of Authority? Or maybe something entirely different?\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Block structure and efficient storage, message serialization.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"P2P networking, peer discovery, block and transaction gossip.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"State machine, execution runtime, smart contracts.\"), mdx(\"li\", {\n    parentName: \"ul\"\n  }, \"Light client support\")), mdx(\"p\", null, \"Although Substrate does not address the first item, Substrate may help you to deal with the rest by providing existing implementations that were designed, written, and tested with great care, based on our years of experience implementing blockchains.\"), mdx(\"p\", null, \"Sure, you can implement all of those tasks by hand, but then you\\u2019d probably end up with an ad-hoc, poorly tested, and not-very-documented solution, to say the least\\xB2. Not to mention that usually it\\u2019s considered a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"very bad idea\"), \" to design or implement cryptographic algorithms yourself, unless you\\u2019re a cryptography expert and you really know what you\\u2019re doing.\"), mdx(\"p\", null, \"So, by providing generic implementations of typical algorithms, Substrate allows you to concentrate on the essence of your project : the business logic of the chain, i.e., its state machine.\"), mdx(\"p\", null, \"Let\\u2019s walk through the most important parts of a blockchain and see what Substrate may offer.\"), mdx(\"h2\", null, \"Blockchain as persistent storage\"), mdx(\"p\", null, \"The sole purpose of any blockchain is to provide a way to store and mutate data in a verifiable and globally \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"persistent\"), \" way, meaning that all parties have a zero-trust way to check and agree on what values should be considered \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"actual\"), \" in any point in time. Moreover, once such data is sealed, it should be persistent, and depending on the consensus, impossible to modify it.\"), mdx(\"p\", null, \"This property is widely used in cryptocurrencies where persistent storage contains account keys and their actual balances. However, it should be noted that cryptocurrency is not the only possible blockchain application. Basically, almost every system that requires globally coherent, persistent storage and verifiable transaction history may be implemented using blockchain in one way or another.\"), mdx(\"p\", null, \"Substrate provides efficient storage that is very easy to use and that is tightly integrated with the WebAssembly (Wasm) runtime.\"), mdx(\"h2\", null, \"Blockchain as a function\"), mdx(\"p\", null, \"In order to update the chain state and alter its storage according to pending operations, we need to have a point where decisions are made.\"), mdx(\"p\", null, \"Such decision points may be expressed as a function that takes current state and a set of pending operations and yields another state that should be considered the new \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"actual\"), \" state of the chain. In the blockchain world, such a function is called the \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"state transition function\"), \", or STF for short.\"), mdx(\"p\", null, \"Substrate lets you define such a function in a very manageable and portable way. Much like JavaScript that\\u2019s executed on a web page, you may write a set of functions collectively called \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"runtime\"), \", that would act as a STF. Additionally, such an implementation would be portable and would not depend on processor architecture, operating system, browser, or be in any other way platform-dependent.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/images/substrate-in-a-nutshell-figure-one.png\",\n    \"alt\": \"Substrate in a nutshell\",\n    \"title\": \"Substrate in a nutshell\"\n  })), mdx(\"p\", null, \"In fact, even the underlying technologies of Substrate are closely related. Substrate uses WebAssembly as the lingua franca of its runtime, the very same technology that is now being integrated by major companies like Mozilla, Google, and Apple as a faster but still compatible alternative to JavaScript for the web.\"), mdx(\"h2\", null, \"Safety and speed\"), mdx(\"p\", null, \"Having your chain logic and smart contracts written in Wasm means you will have the best tools out there to execute your logic in a fast and reliable way. But Substrate has a way to execute your code even faster\\u2014and without any virtual machine overhead.\"), mdx(\"p\", null, \"One of the most revolutionary parts of Substrate is that the runtime image containing the STF is stored, among other payload, right on the chain. That means that runtime and the whole chain\\u2019s business logic may be updated in a secure and verifiable way. Even more, since both Substrate and its Runtime Module Library\\xB3 are written in Rust programming language, they can be translated to both native code and Wasm.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/images/substrate-in-a-nutshell-figure-two.png\",\n    \"alt\": \"Substrate in a nutshell\",\n    \"title\": \"Substrate in a nutshell\"\n  })), mdx(\"p\", null, \"At any point in time, client software has two copies of the compiled runtime: one that\\u2019s compiled in the software natively, and one that is a Wasm image to be executed in a VM. When executing runtime functions, the client software checks whether the on-chain Wasm version of the runtime matches its compiled-to-native, built-in version. When it does, the client software then delegates execution of the runtime functions to the native code version.\"), mdx(\"h2\", null, \"Forkless upgrades\"), mdx(\"p\", null, \"When the runtime image gets updated on the chain, some clients will not have updated their software yet. In that case, their node would execute the correct version of the runtime by interpreting it on Substrate\\u2019s integrated Wasm virtual machine. So, in any case, all nodes on the network are always able to synchronize the chain correctly (albeit at different levels of efficiency), thus preventing a chain fork.\"), mdx(\"h2\", null, \"Networking\"), mdx(\"p\", null, \"Blockchain depends on having lots of participants communicating over a network. The typical solution is to use Peer-to-Peer technologies for such communication, and Substrate is not an exception here. P2P is a common name for a set of technologies used to create decentralized networking applications.\"), mdx(\"p\", null, \"The main idea is to have a self-sustaining network environment where every participant (usually called a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"node\"), \") is capable of operating within a network without any prior configuration or interaction with an authority.\"), mdx(\"p\", null, \"To ensure that nodes can join or leave the network at any time without affecting overall network connectivity, Substrate uses the\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/libp2p/rust-libp2p\"\n  }, \" Rust implementation\"), \" of \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://libp2p.io/\"\n  }, \"libp2p\"), \", a promising network stack that has everything needed to set up a decentralized network environment.\"), mdx(\"h2\", null, \"Custom messages\"), mdx(\"p\", null, \"In the simplest case, you don\\u2019t even need to think about networking, because Substrate does it all for you. You just provide the state transition function of your blockchain and leave all network interaction to Substrate. However, if your blockchain requires custom messages to be sent, you can customize and extend the network subsystem by providing \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"specialization\"), \" of the network protocol that defines custom messages and their handling logic.\"), mdx(\"h2\", null, \"Consensus\"), mdx(\"p\", null, \"Having a state transition function that allows you to move from one state to another is good, but not enough. You also need a way for all nodes to agree on what the next state should be.\"), mdx(\"p\", null, \"As an owner of a bank account, the last thing you want is to have a situation wherein you and your bank disagree on the amount of money you have in your account. Blockchain allows parties to reach \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"consensus\"), \" without trusting each other (hence zero-trust), even in presence of malicious participants who are actively trying to break the system and steal your money.\"), mdx(\"p\", null, \"This is done using a consensus algorithm with a property called Byzantine Fault Tolerance (BFT). If a system is BFT, it means that the nodes can reach consensus even if some fraction of them behave \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"arbitrarily badly\"), \", including collusion, withholding messages, and being offline. BFT consensus systems achieve resistance against varying degrees of networking issues, where messages can be reordered or delayed. Some BFT consensus systems are designed such that when nodes misbehave (e.g. voting for two blocks at a time), they can be punished and have stake slashed on-chain.\"), mdx(\"p\", null, \"For every consensus engine supported in Substrate, there will be a runtime module designed for handling \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"proofs of misbehavior\"), \". The repercussions of evaluating a proof of misbehavior can be determined by the runtime.\"), mdx(\"p\", null, \"It was mathematically proven that this protocol is viable as long as two thirds of the nodes in the network are not malicious and operate according to the protocol. This is one of the reasons why it is important to have a lot of nodes in the network.\"), mdx(\"p\", null, \"Consensus is a critical part of any blockchain application. Luckily, Substrate provides an existing implementation of BFT consensus that can be used almost out of the box.\"), mdx(\"p\", null, \"Depending on a usage scenario, you may either use existing block authoring logic, or provide your own. In the latter case, you may use the generic implementation of the BFT and adapt it to your needs.\"), mdx(\"p\", null, \"Substrate will continue to evolve and have \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://medium.com/polkadot-network/grandpa-block-finality-in-polkadot-an-introduction-part-1-d08a24a021b5\"\n  }, \"more consensus algorithms\"), \" added to its repertoire including the GHOST-based Recursive Ancestor Deriving Prefix Agreement (GRANDPA) finality gadget developed at the Web3 Foundation.\"), mdx(\"p\", null, \"Also, since Substrate is a fully extendable and customizable framework, it is possible to define your own custom consensus algorithm. In fact, Substrate is so flexible that it may support solutions that are not based on classic blockchain architecture. For example, we are researching how to address the blockchain throughput problem by designing a consensus that is not based on traditional block concept.\"), mdx(\"h2\", null, \"Light client support\"), mdx(\"p\", null, \"Early blockchain implementations were designed in such a way that every node in the network maintained the complete blockchain database locally. This is now referred to as a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"full client,\"), \" meaning that the client has everything it need to operate as a network node.\"), mdx(\"p\", null, \"Full clients, also known as full nodes, are important for chain security. But as the blockchain grows, the client\\u2019s database becomes larger and larger. Currently, mainstream cryptocurrencies have databases of several hundreds of gigabytes.\"), mdx(\"p\", null, \"When the full node is initialized, the first thing it needs to do is to synchronize with the rest of the network. Due to security reasons, such a node could not just download the database from a random node \\u201Cas is.\\u201D Instead, it needs to build its own database from scratch by replaying all transactions since \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"genesis\"), \" (the very first block of the chain). In addition to being computationally expensive, this task requires huge amount of data to be transferred across the network.\"), mdx(\"p\", null, \"I think everyone would agree that downloading half of a terabyte of data to your mobile phone only to buy a sandwich is\\u2026 impractical if not ridiculous. That\\u2019s why, almost right from the start, blockchain developers started to think about a way to reduce the costs of maintaining the node, both in storage space and in network throughput.\"), mdx(\"p\", null, \"In the end, the light client concept was born. In a nutshell, a \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"light client\"), \" is an operating mode of a blockchain node where only the most important data is stored locally and network interaction is reduced to a bare minimum while retaining an acceptable amount of security for almost all interactions anyone is likely to make.\"), mdx(\"p\", null, \"Modest resource requirements finally allowed light client nodes to bootstrap easily and therefore be executed on mobile devices.\"), mdx(\"p\", null, \"Unfortunately, it is a serious undertaking to integrate light client support into an existing blockchain. It is much easier to integrate light clients in a blockchain\\u2019s initial design. Substrate was specifically designed with light client support in mind. Blockchains that are built based on Substrate have light client support right out of the box.\"), mdx(\"h2\", null, \"Conclusion\"), mdx(\"p\", null, \"In this post we have skimmed through the key goals and features of Substrate framework. To cover all aspects of Substrate would take a much longer article, but hopefully you now have a general understanding of the concepts. While this is not enough to start writing your code, at least now you should know what to expect.\"), mdx(\"p\", null, \"For more information, check out the earlier \\u201C\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://paritytech.io/what-is-substrate/\"\n  }, \"What is Substrate?\"), \"\\u201D post by Jack Fransham\", mdx(\"em\", {\n    parentName: \"p\"\n  }, \".\"), \" If you\\u2019d like to dig in and start implementing your blockchain, the best place to start is the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://wiki.parity.io/\"\n  }, \"Parity Substrate Wiki\"), \". Also, don\\u2019t hesitate looking at the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/paritytech/substrate\"\n  }, \"source code\"), \", especially the \", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://github.com/paritytech/substrate/blob/master/README.adoc\"\n  }, \"ReadMe file\"), \".\"), mdx(\"hr\", null), mdx(\"h3\", null, mdx(\"strong\", {\n    parentName: \"h3\"\n  }, \"Footnotes\")), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"RNG stands for Random Number Generator. Not every RNG is suitable for blockchain applications.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Substrate itself is now in the very active phase of development. The code base is very volatile and documentation is a work in progress. We are actively populating \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://wiki.parity.io/\"\n  }, \"the wiki\"), \", which is a great place to look for more details.\"), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Runtime module library is an optional set of Rust crates that deals with common tasks, like parameter serialization and call dispatch, and helps you build your runtime at minimal cost. This library is completely optional, so it\\u2019s perfectly fine to design your own runtime from scratch, or use any language that may be compiled to Wasm. Aside from Rust, currently only C and C++ support Wasm as a target architecture.\")));\n}\n;\nMDXContent.isMDXComponent = true;","timeToRead":8,"excerpt":"Today we’ll be talking about  Substrate , a library that can help you build your own custom blockchain. Substrate is created by  Parity…"},"allMdx":{"edges":[{"node":{"frontmatter":{"blogTitle":"We just released ink! 4.0!","date_published":"February 08, 2023","image":"/images/qsdh5p9.jpeg","slug":"we-just-released-ink-4-0"}}},{"node":{"frontmatter":{"blogTitle":"Parity Leadership Update","date_published":"October 21, 2022","image":"/images/blog-post.png","slug":"blog/parity-leadership-update/"}}},{"node":{"frontmatter":{"blogTitle":"Transitioning Parity Ethereum to OpenEthereum DAO","date_published":"December 16, 2019","image":"/images/parity-ethereum-openethereum.jpeg","slug":"blog/parity-ethereum-openethereum-dao/"}}}]}},"pageContext":{"slug":"blog/substrate-in-a-nutshell/","locale":"en","hrefLang":"en-US","originalPath":"/blog/substrate-in-a-nutshell/","dateFormat":"MM/DD/YYYY"}},"staticQueryHashes":["1239077767","1247656359","3280999885","3280999885","4123762078","4185913137","607815487","607815487"]}