{"componentChunkName":"component---src-components-templates-blog-template-tsx","path":"/blog/building-a-hot-wallet-with-substrate-primitives/","result":{"data":{"mdx":{"frontmatter":{"author":"Joe Petrowski","date_published":"November 17, 2020","image":"/images/substrate-low-level-runtime-primitives-06-1.png","slug":"blog/building-a-hot-wallet-with-substrate-primitives/","tags":["Parity Substrate"],"blogTitle":"Building a Hot Wallet With Substrate Primitives"},"body":"var _excluded = [\"components\"];\nfunction _extends() { _extends = Object.assign ? Object.assign.bind() : function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return _extends.apply(this, arguments); }\nfunction _objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = _objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }\nfunction _objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }\n/* @jsxRuntime classic */\n/* @jsx mdx */\n\nvar _frontmatter = {\n  \"tags\": [\"Parity Substrate\"],\n  \"author\": \"Joe Petrowski\",\n  \"blogTitle\": \"Building a Hot Wallet With Substrate Primitives\",\n  \"slug\": \"blog/building-a-hot-wallet-with-substrate-primitives/\",\n  \"date_published\": \"2020-11-17T23:00:00.000Z\",\n  \"image\": \"/images/substrate-low-level-runtime-primitives-06-1.png\"\n};\nvar layoutProps = {\n  _frontmatter: _frontmatter\n};\nvar MDXLayout = \"wrapper\";\nreturn function MDXContent(_ref) {\n  var components = _ref.components,\n    props = _objectWithoutProperties(_ref, _excluded);\n  return mdx(MDXLayout, _extends({}, layoutProps, props, {\n    components: components,\n    mdxType: \"MDXLayout\"\n  }), mdx(\"p\", null, \"Substrate and the FRAME system for runtime development define a powerful set of primitive functions for building blockchain infrastructure. Used in concert, they create novel approaches to existing problems. This article will describe a real-world application where Substrate\\u2019s functions are used to implement a multi-address hot wallet.\"), mdx(\"p\", null, \"A hot wallet usually means that the spending keys are kept on an online device so that it can create and broadcast transactions with convenience, but typically at higher risk. This article will explore some of Substrate\\u2019s account abstractions \\u2014 multi-signature accounts, proxy accounts, and derivative accounts \\u2014 that allow us to construct a hot wallet that could securely support millions of addresses.\"), mdx(\"p\", null, \"Such a wallet would be useful if you needed to hold tokens for several user accounts, but wanted to give each customer their own deposit address. The trivial solution would be to generate a new deposit address for each customer by generating a new key pair. But handling all those keys quickly becomes non-trivial. What if you have tens or hundreds of thousands of users? Using Substrate\\u2019s account abstractions, we can build a solution that is both more scalable and more secure.\"), mdx(\"h2\", null, \"Origins and Account IDs\"), mdx(\"p\", null, \"Before starting to build the hot wallet, we need to lay the foundations it will use. When a user interacts with a blockchain, they are calling some function; the set of these \\u201Cdispatchable\\u201D functions make up the blockchain\\u2019s interface.\"), mdx(\"p\", null, \"Since dispatchable functions are invoked from the outside world, the first thing the blockchain might care about is who actually called the function. For one, a function needs to check if the caller has the authority to execute this function. Second, the chain might need to know exactly who called the function to update some information about the caller. If the caller is an account, the chain may need to update the account\\u2019s balance, e.g. to deduct a transaction fee.\"), mdx(\"p\", null, \"You might be thinking, \\u201CWhat do you mean \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"if\"), \" the caller is an account?\\u201D Functions in Substrate don\\u2019t come from accounts per se, they come from \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"origins\"), \". The governance system of Polkadot, for example, has a suite of special origins that have privileges such as allocating Treasury funds or cancelling slashes. If you design your own blockchain with Substrate, you can create your own custom origins. But the thing to keep in mind for this article is that an account is simply one variant of a Substrate origin. You can think of this as Substrate telling the dispatchable function, \\u201CThe origin of this dispatch is an account.\\u201D\"), mdx(\"p\", null, \"Now that we\\u2019ve made the first leap of abstraction, we need a way to tell the function which account the origin refers to. If you\\u2019ve used any blockchain, you might be accustomed to an account ID being the public key that corresponds to a private key. That\\u2019s fine, that works in Substrate too. In this sense, an account is \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"identified\"), \" by the public key and \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"authorized\"), \" by the corresponding private key.\"), mdx(\"p\", null, \"Substrate supports more abstraction, though. An account ID can be any 32 byte number.\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.parity.io/building-a-hot-wallet-with-substrate-primitives/#fn1\"\n  }, \"[\", \"1\", \"]\"), \" It could be the public key that corresponds to a private key, but it doesn\\u2019t have to be. It just needs some method of authorization. As in, there must be some unique way to generate this account-identifying number so that Substrate can complete the sentence started above: \\u201CThe origin of this dispatch is an account \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"identified by this number\"), \".\\u201D\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.parity.io/building-a-hot-wallet-with-substrate-primitives/#fn2\"\n  }, \"[\", \"2\", \"]\")), mdx(\"h2\", null, \"Hash Functions\"), mdx(\"p\", null, \"Hash functions come up all the time in blockchain. The blocks are literally linked together via their hashes. But we\\u2019re going to use the properties of hash functions for two more purposes: generating account IDs and identifying function calls.\"), mdx(\"p\", null, \"A hash function takes some input of any size and maps it onto a fixed size output, let\\u2019s say 32 bytes. But it doesn\\u2019t just map data to any 32 byte number, it should deterministically map unique data to a unique number. It just so happens that 32 bytes can capture an astronomically large number of items.\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.parity.io/building-a-hot-wallet-with-substrate-primitives/#fn3\"\n  }, \"[\", \"3\", \"]\")), mdx(\"p\", null, \"For example, we could take some information about a chain, like \\u201Cpolkadot-treasury\\u201D, and turn that into an account ID (32 bytes) by using a hash function. Or, we could take the information about some transaction, e.g. \\u201Ctransfer 10 units to account 123\\u2026\\u201D and trust that the hash is a unique image of that information.\"), mdx(\"h2\", null, \"Multisig Accounts\"), mdx(\"p\", null, \"With that out of the way, we can start building the first part of our hot wallet: a multisig account. Multisig accounts may not seem like part of a hot wallet because of general clunkiness, but this account will serve as a secure base for the rest of the components and said clunkiness will not impede day-to-day usage.\"), mdx(\"p\", null, \"Some blockchains use cryptographic multisig, where multiple key holders sign a single transaction off-chain prior to submitting the transaction on-chain. The multisig system that comes with Substrate\\u2019s FRAME works another way: it generates an account ID based on the individual accounts that make up the multisig and the requisite threshold needed to dispatch from the generated account. Substrate adds a special multisig prefix to all of this information and hashes it to get a single 32 byte output that it will use as the multisig account ID. Notice that this account ID does not have a private key associated with it.\"), mdx(\"p\", null, \"To authorize a transaction from that new account ID, the members of the multisig each submits a transaction on-chain with the function call that they want the multisig account to make. But it\\u2019s not efficient for everyone to submit the function call; it could be large and block space is scarce (and therefore, expensive). Hash functions come in handy again: only one of the individual accounts needs to submit the actual function call; the others only submit the hash. They are saying, \\u201Cwe agree to call the function with this hash from the multisig account,\\u201D and don\\u2019t need to resubmit the function.\"), mdx(\"p\", null, \"This multisig on its own is too clunky for use as a hot wallet because it requires multiple key holders to submit transactions in order to make it work. But it is highly secure and will serve as a base account that we can turn into a hot wallet without sacrificing its security.\"), mdx(\"h2\", null, \"Proxy Accounts\"), mdx(\"p\", null, \"Proxy accounts allow the multisig address to delegate spending authority to another account, which will serve as the hot wallet while still keeping the multisig secure. We will set one time delay proxy to manage spending and another (or many) instant proxies to manage security for this multisig account.\"), mdx(\"p\", null, \"A proxy account gives some privileges from one account to another to make function calls on its behalf. These privileges can be specific, for example, \\u201Conly transactions related to staking\\u201D, or broad, for example, \\u201Call transactions that do not transfer funds\\u201D, or even full privileges, \\u201Cany transaction\\u201D.\"), mdx(\"p\", null, \"Creating a proxy just requires one transaction from the to-be-proxied account stating which other account is its proxy and its privileges. Once the proxy relationship is in place, the proxy account can make transactions for the proxied account, essentially telling the chain, \\u201CI am a proxy for this account, I have these privileges, and I want to dispatch this function call on behalf of the proxied account.\\u201D The chain\\u2019s logic will verify that the proxy does have the correct privileges, and dispatch that function \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"with the origin of the proxied account\"), \".\"), mdx(\"p\", null, \"Adding a time delay adds an extra layer of security. Imagine a time delay of 600 blocks (one hour in Polkadot). The proxy account would still submit a transaction saying that it is a proxy with some privileges, but would only announce the hash of the function call it wants to make. The proxied account\\u2019s owner can request the actual function call and review it. If the owner does not approve, they can reject the function call by submitting another transaction before the time delay expires. After the time delay, the proxy can submit the actual function call that corresponds to the announcement, and Substrate will dispatch it.\", mdx(\"a\", {\n    parentName: \"p\",\n    \"href\": \"https://www.parity.io/building-a-hot-wallet-with-substrate-primitives/#fn4\"\n  }, \"[\", \"4\", \"]\")), mdx(\"p\", null, \"For our use case, the multisig key holders will make a transaction to set another account as a time delay proxy with full privileges, as in including balance transfers. Maybe this proxy account will live on an online server that makes transactions autonomously. Whenever it makes a transaction, it will have to announce the hash first and then send the actual function call to some other account holder (for simplicity, let\\u2019s consider this other account holder a member of the multisig) who can verify that the function call is not malicious. If it is, the multisig can make a transaction in time to reject the call, and out of caution decide that the proxy account has been compromised and remove it.\"), mdx(\"p\", null, \"This setup actually works, but we can still make it more convenient to use. Using only a single proxy, we might require a long time delay because coordinating enough multisig key holders to make a rejection transaction can be difficult on short notice. But one account can have multiple proxy accounts with varying privileges. To solve this problem, set each multisig key holder as a proxy with non-transfer privileges, notably with the privilege to reject announcements from the time delay proxy.\"), mdx(\"p\", null, \"Let\\u2019s recapitulate this configuration. At the center, we have a multisig account. This account does not have a private key, but it has two ways to control it: by using a time delay proxy account or by gathering enough signatories of the member accounts. Each member of the multisig also has the ability to \", mdx(\"em\", {\n    parentName: \"p\"\n  }, \"reject\"), \" transactions from the fully privileged proxy, but cannot make balance transfers without other members joining to make a multisig transaction.\"), mdx(\"p\", null, \"On its own, this is a fully functional hot wallet that can change the hot key (the fully privileged proxy account) without changing its address (the multisig account) by simply removing the proxy and setting a new one. But our original problem statement required unique deposit addresses for tens of thousands of users, and so far we only have one.\"), mdx(\"h2\", null, \"Derivative Accounts\"), mdx(\"p\", null, \"So far we have used multiple ways to access one multisig account; now we will use one account to access many.\"), mdx(\"p\", null, \"Each account in Substrate has a tree of derivative accounts that it can access. To derive the account IDs, and this should be no surprise at this point, Substrate uses a hash algorithm. By hashing the account ID of the calling account with the desired index and a derivative prefix, Substrate creates a new account ID. For example, the sender provides a function call and an index, saying, \\u201CI want to dispatch this function from my derivative account with this index.\\u201D\"), mdx(\"p\", null, \"You probably see where this is going. The wallet owner can assign an index to each of their users, and provide the derivative account ID as the deposit address for that user. To access the funds, the proxy address would issue a transaction to transfer funds from the derivative address of the multisig account.\"), mdx(\"p\", null, \"Practically speaking, the index is limited to 16 bits, or 65,536 derivative accounts, but nesting works too. That is, each derivative account can have its own set of 65,536 derivative accounts, and so on. The second tier of this tree would have over four billion accounts.\"), mdx(\"h2\", null, \"The Full Picture\"), mdx(\"p\", null, \"Let\\u2019s finally use this. Imagine that the user with index 11 pays you and you have some \\u201Csavings account\\u201D that you want to deposit the funds into. The full transaction would look like: \\u201CI am a proxy for the multisig account, and I want to transfer funds from the multisig\\u2019s derivative account with index 11 to the savings account.\\u201D\"), mdx(\"p\", null, \"Assuming that everything looks OK to the supervisors, the time delay would expire and the proxy can broadcast the full transaction. If the multisig members ever think that the hot key needs changing, they can simply generate a new one and remove the old one as a proxy, without affecting the multisig or any of its derivative addresses.\"), mdx(\"p\", null, mdx(\"img\", {\n    parentName: \"p\",\n    \"src\": \"/images/substrate-low-level-runtime-primitives-07-1.png\",\n    \"alt\": \"substrate-low-level-runtime-primitives-07-1-\"\n  })), mdx(\"p\", null, \"The above image shows a diagram of the wallet we've set up: a multisig (MS) is controlled by a set of n keys (noted k) and sets a time delay proxy (H) to be a hotkey. From the multisig, it can derive virtually unlimited addresses (the set of d).\"), mdx(\"p\", null, \"We can even optimize this workflow more. Substrate also provides a function to send a batch of function calls. If users deposit to and withdraw from their derivative accounts on a regular basis, you can send them all in a single batch of transfers.\"), mdx(\"p\", null, \"Substrate\\u2019s on-chain account abstractions provide powerful ways to manage accounts. By reducing the number of actual keys needed and accessing accounts based on formal rules rather than private keys, you can operate hundreds of thousands of accounts without dealing with the limitations of storing an equivalent number of signing keys. This article just focused on one example, building a hot wallet, but all of the abstractions are isolated and can be composed into more advanced applications.\"), mdx(\"hr\", null), mdx(\"ol\", null, mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"It doesn\\u2019t have to be 32 bytes. You can build your runtime with whatever you like, but I don\\u2019t want this article to digress into runtime development any more than it must. \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://www.parity.io/building-a-hot-wallet-with-substrate-primitives/#fnref1\"\n  }, \"\\u21A9\\uFE0E\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"A quick interruption on the word \\u201Cunique\\u201D, which I mean in a more rigorous sense than your average dictionary definition. A function is unique not if there exists only one representation of it, but rather if all representations (or series of representations) are provably equivalent. There could exist an infinite number of methods to generate one particular number (account), but as long as all of those methods do generate that same account, then that account can be considered unique. Going down this path any further will lead to the kind of mathematics that keeps you up at night, but we\\u2019re going to be generating account IDs and passing them around between functions, and the key takeaway here is that no matter how many functions we string together (put in series) to reach some account ID, it behaves as the same account ID in its capacity as a dispatch origin. \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://www.parity.io/building-a-hot-wallet-with-substrate-primitives/#fnref2\"\n  }, \"\\u21A9\\uFE0E\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"If you\\u2019re interested, 32 bytes can hold up to the number 1.15x10^77. The distance to the edge of the observable universe is 45.7 billion light years, which is 4.32x10^23 kilometers, or 4.32x10^29 millimeters. If we consider that a flat disc, it has an area of 5.87x10^59 square millimeters. We\\u2019re still off by a factor of 10^18, or a billion squared. So the chances of two different hash inputs having the same output is like both items landing on the same square millimeter in the observable universe, then breaking that down into a 1 billion by 1 billion grid and again both landing in the same square. Those squares are 1 picometer wide. For reference, a helium atom has a diameter of 62 picometers. \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://www.parity.io/building-a-hot-wallet-with-substrate-primitives/#fnref3\"\n  }, \"\\u21A9\\uFE0E\")), mdx(\"li\", {\n    parentName: \"ol\"\n  }, \"Actually, any account can submit the call, as long as the proxy made the announcement, but for the sake of pragmatism, assume that our hot wallet just uses the same account to announce and submit. \", mdx(\"a\", {\n    parentName: \"li\",\n    \"href\": \"https://www.parity.io/building-a-hot-wallet-with-substrate-primitives/#fnref4\"\n  }, \"\\u21A9\\uFE0E\"))));\n}\n;\nMDXContent.isMDXComponent = true;","timeToRead":9,"excerpt":"Substrate and the FRAME system for runtime development define a powerful set of primitive functions for building blockchain infrastructureâ€¦"},"allMdx":{"edges":[{"node":{"frontmatter":{"blogTitle":"We just released ink! 4.0!","date_published":"February 08, 2023","image":"/images/qsdh5p9.jpeg","slug":"we-just-released-ink-4-0"}}},{"node":{"frontmatter":{"blogTitle":"Parity Leadership Update","date_published":"October 21, 2022","image":"/images/blog-post.png","slug":"blog/parity-leadership-update/"}}},{"node":{"frontmatter":{"blogTitle":"Substrate Builders Program Milestone Update: June 2021","date_published":"June 09, 2021","image":"/images/substrate_builders_program_blog-23-1.png","slug":"blog/substrate-builders-program-milestone-update-june-2021"}}}]}},"pageContext":{"slug":"blog/building-a-hot-wallet-with-substrate-primitives/","locale":"en","hrefLang":"en-US","originalPath":"/blog/building-a-hot-wallet-with-substrate-primitives/","dateFormat":"MM/DD/YYYY"}},"staticQueryHashes":["1239077767","1247656359","3280999885","3280999885","4123762078","4185913137","607815487","607815487"]}